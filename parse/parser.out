Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> ast
Rule 1     ast -> class_list
Rule 2     class_list -> class_ast semi class_list
Rule 3     class_list -> class_ast semi
Rule 4     class_ast -> class type lbrace rbrace
Rule 5     class_ast -> class type lbrace feature_list rbrace
Rule 6     class_ast -> class type inherits type lbrace rbrace
Rule 7     class_ast -> class type inherits type lbrace feature_list rbrace
Rule 8     feature_list -> feature semi feature_list
Rule 9     feature_list -> feature semi
Rule 10    feature -> identifier colon type
Rule 11    feature -> identifier colon type larrow exp
Rule 12    feature -> identifier lparen formal_list rparen colon type lbrace exp rbrace
Rule 13    feature -> identifier lparen rparen colon type lbrace exp rbrace
Rule 14    formal_list -> formal comma formal_list
Rule 15    formal_list -> formal
Rule 16    formal -> identifier colon type
Rule 17    exp -> identifier larrow exp
Rule 18    exp -> exp dot identifier lparen param_list rparen
Rule 19    exp -> exp dot identifier lparen rparen
Rule 20    exp -> exp at type dot identifier lparen param_list rparen
Rule 21    exp -> exp at type dot identifier lparen rparen
Rule 22    exp -> identifier lparen param_list rparen
Rule 23    exp -> identifier lparen rparen
Rule 24    param_list -> exp comma param_list
Rule 25    param_list -> exp
Rule 26    exp -> if exp then exp else exp fi
Rule 27    exp -> while exp loop exp pool
Rule 28    exp -> lbrace exp_list rbrace
Rule 29    exp_list -> exp semi exp_list
Rule 30    exp_list -> exp semi
Rule 31    exp -> let let_binding_list in exp
Rule 32    let_binding_list -> let_binding comma let_binding_list
Rule 33    let_binding_list -> let_binding
Rule 34    let_binding -> identifier colon type
Rule 35    let_binding -> identifier colon type larrow exp
Rule 36    exp -> case exp of case_elements esac
Rule 37    case_elements -> case_element semi case_elements
Rule 38    case_elements -> case_element semi
Rule 39    case_element -> identifier colon type rarrow exp
Rule 40    exp -> new type
Rule 41    exp -> isvoid exp
Rule 42    exp -> exp plus exp
Rule 43    exp -> exp minus exp
Rule 44    exp -> exp times exp
Rule 45    exp -> exp divide exp
Rule 46    exp -> tilde exp
Rule 47    exp -> exp lt exp
Rule 48    exp -> exp le exp
Rule 49    exp -> exp equals exp
Rule 50    exp -> not exp
Rule 51    exp -> lparen exp rparen
Rule 52    exp -> identifier
Rule 53    exp -> integer
Rule 54    exp -> string
Rule 55    exp -> true
Rule 56    exp -> false

Terminals, with rules where they appear

at                   : 20 21
case                 : 36
class                : 4 5 6 7
colon                : 10 11 12 13 16 34 35 39
comma                : 14 24 32
divide               : 45
dot                  : 18 19 20 21
else                 : 26
equals               : 49
error                : 
esac                 : 36
false                : 56
fi                   : 26
identifier           : 10 11 12 13 16 17 18 19 20 21 22 23 34 35 39 52
if                   : 26
in                   : 31
inherits             : 6 7
integer              : 53
isvoid               : 41
larrow               : 11 17 35
lbrace               : 4 5 6 7 12 13 28
le                   : 48
let                  : 31
loop                 : 27
lparen               : 12 13 18 19 20 21 22 23 51
lt                   : 47
minus                : 43
new                  : 40
not                  : 50
of                   : 36
plus                 : 42
pool                 : 27
rarrow               : 39
rbrace               : 4 5 6 7 12 13 28
rparen               : 12 13 18 19 20 21 22 23 51
semi                 : 2 3 8 9 29 30 37 38
string               : 54
then                 : 26
tilde                : 46
times                : 44
true                 : 55
type                 : 4 5 6 6 7 7 10 11 12 13 16 20 21 34 35 39 40
while                : 27

Nonterminals, with rules where they appear

ast                  : 0
case_element         : 37 38
case_elements        : 36 37
class_ast            : 2 3
class_list           : 1 2
exp                  : 11 12 13 17 18 19 20 21 24 25 26 26 26 27 27 29 30 31 35 36 39 41 42 42 43 43 44 44 45 45 46 47 47 48 48 49 49 50 51
exp_list             : 28 29
feature              : 8 9
feature_list         : 5 7 8
formal               : 14 15
formal_list          : 12 14
let_binding          : 32 33
let_binding_list     : 31 32
param_list           : 18 20 22 24

Parsing method: LALR

state 0

    (0) S' -> . ast
    (1) ast -> . class_list
    (2) class_list -> . class_ast semi class_list
    (3) class_list -> . class_ast semi
    (4) class_ast -> . class type lbrace rbrace
    (5) class_ast -> . class type lbrace feature_list rbrace
    (6) class_ast -> . class type inherits type lbrace rbrace
    (7) class_ast -> . class type inherits type lbrace feature_list rbrace

    class           shift and go to state 4

    class_ast                      shift and go to state 1
    class_list                     shift and go to state 3
    ast                            shift and go to state 2

state 1

    (2) class_list -> class_ast . semi class_list
    (3) class_list -> class_ast . semi

    semi            shift and go to state 5


state 2

    (0) S' -> ast .



state 3

    (1) ast -> class_list .

    $end            reduce using rule 1 (ast -> class_list .)


state 4

    (4) class_ast -> class . type lbrace rbrace
    (5) class_ast -> class . type lbrace feature_list rbrace
    (6) class_ast -> class . type inherits type lbrace rbrace
    (7) class_ast -> class . type inherits type lbrace feature_list rbrace

    type            shift and go to state 6


state 5

    (2) class_list -> class_ast semi . class_list
    (3) class_list -> class_ast semi .
    (2) class_list -> . class_ast semi class_list
    (3) class_list -> . class_ast semi
    (4) class_ast -> . class type lbrace rbrace
    (5) class_ast -> . class type lbrace feature_list rbrace
    (6) class_ast -> . class type inherits type lbrace rbrace
    (7) class_ast -> . class type inherits type lbrace feature_list rbrace

    $end            reduce using rule 3 (class_list -> class_ast semi .)
    class           shift and go to state 4

    class_ast                      shift and go to state 1
    class_list                     shift and go to state 7

state 6

    (4) class_ast -> class type . lbrace rbrace
    (5) class_ast -> class type . lbrace feature_list rbrace
    (6) class_ast -> class type . inherits type lbrace rbrace
    (7) class_ast -> class type . inherits type lbrace feature_list rbrace

    lbrace          shift and go to state 9
    inherits        shift and go to state 8


state 7

    (2) class_list -> class_ast semi class_list .

    $end            reduce using rule 2 (class_list -> class_ast semi class_list .)


state 8

    (6) class_ast -> class type inherits . type lbrace rbrace
    (7) class_ast -> class type inherits . type lbrace feature_list rbrace

    type            shift and go to state 10


state 9

    (4) class_ast -> class type lbrace . rbrace
    (5) class_ast -> class type lbrace . feature_list rbrace
    (8) feature_list -> . feature semi feature_list
    (9) feature_list -> . feature semi
    (10) feature -> . identifier colon type
    (11) feature -> . identifier colon type larrow exp
    (12) feature -> . identifier lparen formal_list rparen colon type lbrace exp rbrace
    (13) feature -> . identifier lparen rparen colon type lbrace exp rbrace

    rbrace          shift and go to state 14
    identifier      shift and go to state 13

    feature_list                   shift and go to state 11
    feature                        shift and go to state 12

state 10

    (6) class_ast -> class type inherits type . lbrace rbrace
    (7) class_ast -> class type inherits type . lbrace feature_list rbrace

    lbrace          shift and go to state 15


state 11

    (5) class_ast -> class type lbrace feature_list . rbrace

    rbrace          shift and go to state 16


state 12

    (8) feature_list -> feature . semi feature_list
    (9) feature_list -> feature . semi

    semi            shift and go to state 17


state 13

    (10) feature -> identifier . colon type
    (11) feature -> identifier . colon type larrow exp
    (12) feature -> identifier . lparen formal_list rparen colon type lbrace exp rbrace
    (13) feature -> identifier . lparen rparen colon type lbrace exp rbrace

    colon           shift and go to state 18
    lparen          shift and go to state 19


state 14

    (4) class_ast -> class type lbrace rbrace .

    semi            reduce using rule 4 (class_ast -> class type lbrace rbrace .)


state 15

    (6) class_ast -> class type inherits type lbrace . rbrace
    (7) class_ast -> class type inherits type lbrace . feature_list rbrace
    (8) feature_list -> . feature semi feature_list
    (9) feature_list -> . feature semi
    (10) feature -> . identifier colon type
    (11) feature -> . identifier colon type larrow exp
    (12) feature -> . identifier lparen formal_list rparen colon type lbrace exp rbrace
    (13) feature -> . identifier lparen rparen colon type lbrace exp rbrace

    rbrace          shift and go to state 21
    identifier      shift and go to state 13

    feature_list                   shift and go to state 20
    feature                        shift and go to state 12

state 16

    (5) class_ast -> class type lbrace feature_list rbrace .

    semi            reduce using rule 5 (class_ast -> class type lbrace feature_list rbrace .)


state 17

    (8) feature_list -> feature semi . feature_list
    (9) feature_list -> feature semi .
    (8) feature_list -> . feature semi feature_list
    (9) feature_list -> . feature semi
    (10) feature -> . identifier colon type
    (11) feature -> . identifier colon type larrow exp
    (12) feature -> . identifier lparen formal_list rparen colon type lbrace exp rbrace
    (13) feature -> . identifier lparen rparen colon type lbrace exp rbrace

    rbrace          reduce using rule 9 (feature_list -> feature semi .)
    identifier      shift and go to state 13

    feature                        shift and go to state 12
    feature_list                   shift and go to state 22

state 18

    (10) feature -> identifier colon . type
    (11) feature -> identifier colon . type larrow exp

    type            shift and go to state 23


state 19

    (12) feature -> identifier lparen . formal_list rparen colon type lbrace exp rbrace
    (13) feature -> identifier lparen . rparen colon type lbrace exp rbrace
    (14) formal_list -> . formal comma formal_list
    (15) formal_list -> . formal
    (16) formal -> . identifier colon type

    rparen          shift and go to state 24
    identifier      shift and go to state 27

    formal                         shift and go to state 26
    formal_list                    shift and go to state 25

state 20

    (7) class_ast -> class type inherits type lbrace feature_list . rbrace

    rbrace          shift and go to state 28


state 21

    (6) class_ast -> class type inherits type lbrace rbrace .

    semi            reduce using rule 6 (class_ast -> class type inherits type lbrace rbrace .)


state 22

    (8) feature_list -> feature semi feature_list .

    rbrace          reduce using rule 8 (feature_list -> feature semi feature_list .)


state 23

    (10) feature -> identifier colon type .
    (11) feature -> identifier colon type . larrow exp

    semi            reduce using rule 10 (feature -> identifier colon type .)
    larrow          shift and go to state 29


state 24

    (13) feature -> identifier lparen rparen . colon type lbrace exp rbrace

    colon           shift and go to state 30


state 25

    (12) feature -> identifier lparen formal_list . rparen colon type lbrace exp rbrace

    rparen          shift and go to state 31


state 26

    (14) formal_list -> formal . comma formal_list
    (15) formal_list -> formal .

    comma           shift and go to state 32
    rparen          reduce using rule 15 (formal_list -> formal .)


state 27

    (16) formal -> identifier . colon type

    colon           shift and go to state 33


state 28

    (7) class_ast -> class type inherits type lbrace feature_list rbrace .

    semi            reduce using rule 7 (class_ast -> class type inherits type lbrace feature_list rbrace .)


state 29

    (11) feature -> identifier colon type larrow . exp
    (17) exp -> . identifier larrow exp
    (18) exp -> . exp dot identifier lparen param_list rparen
    (19) exp -> . exp dot identifier lparen rparen
    (20) exp -> . exp at type dot identifier lparen param_list rparen
    (21) exp -> . exp at type dot identifier lparen rparen
    (22) exp -> . identifier lparen param_list rparen
    (23) exp -> . identifier lparen rparen
    (26) exp -> . if exp then exp else exp fi
    (27) exp -> . while exp loop exp pool
    (28) exp -> . lbrace exp_list rbrace
    (31) exp -> . let let_binding_list in exp
    (36) exp -> . case exp of case_elements esac
    (40) exp -> . new type
    (41) exp -> . isvoid exp
    (42) exp -> . exp plus exp
    (43) exp -> . exp minus exp
    (44) exp -> . exp times exp
    (45) exp -> . exp divide exp
    (46) exp -> . tilde exp
    (47) exp -> . exp lt exp
    (48) exp -> . exp le exp
    (49) exp -> . exp equals exp
    (50) exp -> . not exp
    (51) exp -> . lparen exp rparen
    (52) exp -> . identifier
    (53) exp -> . integer
    (54) exp -> . string
    (55) exp -> . true
    (56) exp -> . false

    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 47
    lbrace          shift and go to state 46
    let             shift and go to state 41
    case            shift and go to state 45
    new             shift and go to state 39
    isvoid          shift and go to state 38
    tilde           shift and go to state 35
    not             shift and go to state 43
    lparen          shift and go to state 42
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 44
    false           shift and go to state 34

    exp                            shift and go to state 48

state 30

    (13) feature -> identifier lparen rparen colon . type lbrace exp rbrace

    type            shift and go to state 50


state 31

    (12) feature -> identifier lparen formal_list rparen . colon type lbrace exp rbrace

    colon           shift and go to state 51


state 32

    (14) formal_list -> formal comma . formal_list
    (14) formal_list -> . formal comma formal_list
    (15) formal_list -> . formal
    (16) formal -> . identifier colon type

    identifier      shift and go to state 27

    formal_list                    shift and go to state 52
    formal                         shift and go to state 26

state 33

    (16) formal -> identifier colon . type

    type            shift and go to state 53


state 34

    (56) exp -> false .

    of              reduce using rule 56 (exp -> false .)
    dot             reduce using rule 56 (exp -> false .)
    at              reduce using rule 56 (exp -> false .)
    plus            reduce using rule 56 (exp -> false .)
    minus           reduce using rule 56 (exp -> false .)
    times           reduce using rule 56 (exp -> false .)
    divide          reduce using rule 56 (exp -> false .)
    lt              reduce using rule 56 (exp -> false .)
    le              reduce using rule 56 (exp -> false .)
    equals          reduce using rule 56 (exp -> false .)
    semi            reduce using rule 56 (exp -> false .)
    then            reduce using rule 56 (exp -> false .)
    rparen          reduce using rule 56 (exp -> false .)
    loop            reduce using rule 56 (exp -> false .)
    comma           reduce using rule 56 (exp -> false .)
    rbrace          reduce using rule 56 (exp -> false .)
    else            reduce using rule 56 (exp -> false .)
    pool            reduce using rule 56 (exp -> false .)
    fi              reduce using rule 56 (exp -> false .)
    in              reduce using rule 56 (exp -> false .)


state 35

    (46) exp -> tilde . exp
    (17) exp -> . identifier larrow exp
    (18) exp -> . exp dot identifier lparen param_list rparen
    (19) exp -> . exp dot identifier lparen rparen
    (20) exp -> . exp at type dot identifier lparen param_list rparen
    (21) exp -> . exp at type dot identifier lparen rparen
    (22) exp -> . identifier lparen param_list rparen
    (23) exp -> . identifier lparen rparen
    (26) exp -> . if exp then exp else exp fi
    (27) exp -> . while exp loop exp pool
    (28) exp -> . lbrace exp_list rbrace
    (31) exp -> . let let_binding_list in exp
    (36) exp -> . case exp of case_elements esac
    (40) exp -> . new type
    (41) exp -> . isvoid exp
    (42) exp -> . exp plus exp
    (43) exp -> . exp minus exp
    (44) exp -> . exp times exp
    (45) exp -> . exp divide exp
    (46) exp -> . tilde exp
    (47) exp -> . exp lt exp
    (48) exp -> . exp le exp
    (49) exp -> . exp equals exp
    (50) exp -> . not exp
    (51) exp -> . lparen exp rparen
    (52) exp -> . identifier
    (53) exp -> . integer
    (54) exp -> . string
    (55) exp -> . true
    (56) exp -> . false

    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 47
    lbrace          shift and go to state 46
    let             shift and go to state 41
    case            shift and go to state 45
    new             shift and go to state 39
    isvoid          shift and go to state 38
    tilde           shift and go to state 35
    not             shift and go to state 43
    lparen          shift and go to state 42
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 44
    false           shift and go to state 34

    exp                            shift and go to state 54

state 36

    (26) exp -> if . exp then exp else exp fi
    (17) exp -> . identifier larrow exp
    (18) exp -> . exp dot identifier lparen param_list rparen
    (19) exp -> . exp dot identifier lparen rparen
    (20) exp -> . exp at type dot identifier lparen param_list rparen
    (21) exp -> . exp at type dot identifier lparen rparen
    (22) exp -> . identifier lparen param_list rparen
    (23) exp -> . identifier lparen rparen
    (26) exp -> . if exp then exp else exp fi
    (27) exp -> . while exp loop exp pool
    (28) exp -> . lbrace exp_list rbrace
    (31) exp -> . let let_binding_list in exp
    (36) exp -> . case exp of case_elements esac
    (40) exp -> . new type
    (41) exp -> . isvoid exp
    (42) exp -> . exp plus exp
    (43) exp -> . exp minus exp
    (44) exp -> . exp times exp
    (45) exp -> . exp divide exp
    (46) exp -> . tilde exp
    (47) exp -> . exp lt exp
    (48) exp -> . exp le exp
    (49) exp -> . exp equals exp
    (50) exp -> . not exp
    (51) exp -> . lparen exp rparen
    (52) exp -> . identifier
    (53) exp -> . integer
    (54) exp -> . string
    (55) exp -> . true
    (56) exp -> . false

    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 47
    lbrace          shift and go to state 46
    let             shift and go to state 41
    case            shift and go to state 45
    new             shift and go to state 39
    isvoid          shift and go to state 38
    tilde           shift and go to state 35
    not             shift and go to state 43
    lparen          shift and go to state 42
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 44
    false           shift and go to state 34

    exp                            shift and go to state 55

state 37

    (53) exp -> integer .

    of              reduce using rule 53 (exp -> integer .)
    dot             reduce using rule 53 (exp -> integer .)
    at              reduce using rule 53 (exp -> integer .)
    plus            reduce using rule 53 (exp -> integer .)
    minus           reduce using rule 53 (exp -> integer .)
    times           reduce using rule 53 (exp -> integer .)
    divide          reduce using rule 53 (exp -> integer .)
    lt              reduce using rule 53 (exp -> integer .)
    le              reduce using rule 53 (exp -> integer .)
    equals          reduce using rule 53 (exp -> integer .)
    semi            reduce using rule 53 (exp -> integer .)
    then            reduce using rule 53 (exp -> integer .)
    rparen          reduce using rule 53 (exp -> integer .)
    loop            reduce using rule 53 (exp -> integer .)
    comma           reduce using rule 53 (exp -> integer .)
    rbrace          reduce using rule 53 (exp -> integer .)
    else            reduce using rule 53 (exp -> integer .)
    pool            reduce using rule 53 (exp -> integer .)
    fi              reduce using rule 53 (exp -> integer .)
    in              reduce using rule 53 (exp -> integer .)


state 38

    (41) exp -> isvoid . exp
    (17) exp -> . identifier larrow exp
    (18) exp -> . exp dot identifier lparen param_list rparen
    (19) exp -> . exp dot identifier lparen rparen
    (20) exp -> . exp at type dot identifier lparen param_list rparen
    (21) exp -> . exp at type dot identifier lparen rparen
    (22) exp -> . identifier lparen param_list rparen
    (23) exp -> . identifier lparen rparen
    (26) exp -> . if exp then exp else exp fi
    (27) exp -> . while exp loop exp pool
    (28) exp -> . lbrace exp_list rbrace
    (31) exp -> . let let_binding_list in exp
    (36) exp -> . case exp of case_elements esac
    (40) exp -> . new type
    (41) exp -> . isvoid exp
    (42) exp -> . exp plus exp
    (43) exp -> . exp minus exp
    (44) exp -> . exp times exp
    (45) exp -> . exp divide exp
    (46) exp -> . tilde exp
    (47) exp -> . exp lt exp
    (48) exp -> . exp le exp
    (49) exp -> . exp equals exp
    (50) exp -> . not exp
    (51) exp -> . lparen exp rparen
    (52) exp -> . identifier
    (53) exp -> . integer
    (54) exp -> . string
    (55) exp -> . true
    (56) exp -> . false

    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 47
    lbrace          shift and go to state 46
    let             shift and go to state 41
    case            shift and go to state 45
    new             shift and go to state 39
    isvoid          shift and go to state 38
    tilde           shift and go to state 35
    not             shift and go to state 43
    lparen          shift and go to state 42
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 44
    false           shift and go to state 34

    exp                            shift and go to state 56

state 39

    (40) exp -> new . type

    type            shift and go to state 57


state 40

    (54) exp -> string .

    of              reduce using rule 54 (exp -> string .)
    dot             reduce using rule 54 (exp -> string .)
    at              reduce using rule 54 (exp -> string .)
    plus            reduce using rule 54 (exp -> string .)
    minus           reduce using rule 54 (exp -> string .)
    times           reduce using rule 54 (exp -> string .)
    divide          reduce using rule 54 (exp -> string .)
    lt              reduce using rule 54 (exp -> string .)
    le              reduce using rule 54 (exp -> string .)
    equals          reduce using rule 54 (exp -> string .)
    semi            reduce using rule 54 (exp -> string .)
    then            reduce using rule 54 (exp -> string .)
    rparen          reduce using rule 54 (exp -> string .)
    loop            reduce using rule 54 (exp -> string .)
    comma           reduce using rule 54 (exp -> string .)
    rbrace          reduce using rule 54 (exp -> string .)
    else            reduce using rule 54 (exp -> string .)
    pool            reduce using rule 54 (exp -> string .)
    fi              reduce using rule 54 (exp -> string .)
    in              reduce using rule 54 (exp -> string .)


state 41

    (31) exp -> let . let_binding_list in exp
    (32) let_binding_list -> . let_binding comma let_binding_list
    (33) let_binding_list -> . let_binding
    (34) let_binding -> . identifier colon type
    (35) let_binding -> . identifier colon type larrow exp

    identifier      shift and go to state 60

    let_binding                    shift and go to state 59
    let_binding_list               shift and go to state 58

state 42

    (51) exp -> lparen . exp rparen
    (17) exp -> . identifier larrow exp
    (18) exp -> . exp dot identifier lparen param_list rparen
    (19) exp -> . exp dot identifier lparen rparen
    (20) exp -> . exp at type dot identifier lparen param_list rparen
    (21) exp -> . exp at type dot identifier lparen rparen
    (22) exp -> . identifier lparen param_list rparen
    (23) exp -> . identifier lparen rparen
    (26) exp -> . if exp then exp else exp fi
    (27) exp -> . while exp loop exp pool
    (28) exp -> . lbrace exp_list rbrace
    (31) exp -> . let let_binding_list in exp
    (36) exp -> . case exp of case_elements esac
    (40) exp -> . new type
    (41) exp -> . isvoid exp
    (42) exp -> . exp plus exp
    (43) exp -> . exp minus exp
    (44) exp -> . exp times exp
    (45) exp -> . exp divide exp
    (46) exp -> . tilde exp
    (47) exp -> . exp lt exp
    (48) exp -> . exp le exp
    (49) exp -> . exp equals exp
    (50) exp -> . not exp
    (51) exp -> . lparen exp rparen
    (52) exp -> . identifier
    (53) exp -> . integer
    (54) exp -> . string
    (55) exp -> . true
    (56) exp -> . false

    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 47
    lbrace          shift and go to state 46
    let             shift and go to state 41
    case            shift and go to state 45
    new             shift and go to state 39
    isvoid          shift and go to state 38
    tilde           shift and go to state 35
    not             shift and go to state 43
    lparen          shift and go to state 42
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 44
    false           shift and go to state 34

    exp                            shift and go to state 61

state 43

    (50) exp -> not . exp
    (17) exp -> . identifier larrow exp
    (18) exp -> . exp dot identifier lparen param_list rparen
    (19) exp -> . exp dot identifier lparen rparen
    (20) exp -> . exp at type dot identifier lparen param_list rparen
    (21) exp -> . exp at type dot identifier lparen rparen
    (22) exp -> . identifier lparen param_list rparen
    (23) exp -> . identifier lparen rparen
    (26) exp -> . if exp then exp else exp fi
    (27) exp -> . while exp loop exp pool
    (28) exp -> . lbrace exp_list rbrace
    (31) exp -> . let let_binding_list in exp
    (36) exp -> . case exp of case_elements esac
    (40) exp -> . new type
    (41) exp -> . isvoid exp
    (42) exp -> . exp plus exp
    (43) exp -> . exp minus exp
    (44) exp -> . exp times exp
    (45) exp -> . exp divide exp
    (46) exp -> . tilde exp
    (47) exp -> . exp lt exp
    (48) exp -> . exp le exp
    (49) exp -> . exp equals exp
    (50) exp -> . not exp
    (51) exp -> . lparen exp rparen
    (52) exp -> . identifier
    (53) exp -> . integer
    (54) exp -> . string
    (55) exp -> . true
    (56) exp -> . false

    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 47
    lbrace          shift and go to state 46
    let             shift and go to state 41
    case            shift and go to state 45
    new             shift and go to state 39
    isvoid          shift and go to state 38
    tilde           shift and go to state 35
    not             shift and go to state 43
    lparen          shift and go to state 42
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 44
    false           shift and go to state 34

    exp                            shift and go to state 62

state 44

    (55) exp -> true .

    of              reduce using rule 55 (exp -> true .)
    dot             reduce using rule 55 (exp -> true .)
    at              reduce using rule 55 (exp -> true .)
    plus            reduce using rule 55 (exp -> true .)
    minus           reduce using rule 55 (exp -> true .)
    times           reduce using rule 55 (exp -> true .)
    divide          reduce using rule 55 (exp -> true .)
    lt              reduce using rule 55 (exp -> true .)
    le              reduce using rule 55 (exp -> true .)
    equals          reduce using rule 55 (exp -> true .)
    semi            reduce using rule 55 (exp -> true .)
    then            reduce using rule 55 (exp -> true .)
    rparen          reduce using rule 55 (exp -> true .)
    loop            reduce using rule 55 (exp -> true .)
    comma           reduce using rule 55 (exp -> true .)
    rbrace          reduce using rule 55 (exp -> true .)
    else            reduce using rule 55 (exp -> true .)
    pool            reduce using rule 55 (exp -> true .)
    fi              reduce using rule 55 (exp -> true .)
    in              reduce using rule 55 (exp -> true .)


state 45

    (36) exp -> case . exp of case_elements esac
    (17) exp -> . identifier larrow exp
    (18) exp -> . exp dot identifier lparen param_list rparen
    (19) exp -> . exp dot identifier lparen rparen
    (20) exp -> . exp at type dot identifier lparen param_list rparen
    (21) exp -> . exp at type dot identifier lparen rparen
    (22) exp -> . identifier lparen param_list rparen
    (23) exp -> . identifier lparen rparen
    (26) exp -> . if exp then exp else exp fi
    (27) exp -> . while exp loop exp pool
    (28) exp -> . lbrace exp_list rbrace
    (31) exp -> . let let_binding_list in exp
    (36) exp -> . case exp of case_elements esac
    (40) exp -> . new type
    (41) exp -> . isvoid exp
    (42) exp -> . exp plus exp
    (43) exp -> . exp minus exp
    (44) exp -> . exp times exp
    (45) exp -> . exp divide exp
    (46) exp -> . tilde exp
    (47) exp -> . exp lt exp
    (48) exp -> . exp le exp
    (49) exp -> . exp equals exp
    (50) exp -> . not exp
    (51) exp -> . lparen exp rparen
    (52) exp -> . identifier
    (53) exp -> . integer
    (54) exp -> . string
    (55) exp -> . true
    (56) exp -> . false

    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 47
    lbrace          shift and go to state 46
    let             shift and go to state 41
    case            shift and go to state 45
    new             shift and go to state 39
    isvoid          shift and go to state 38
    tilde           shift and go to state 35
    not             shift and go to state 43
    lparen          shift and go to state 42
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 44
    false           shift and go to state 34

    exp                            shift and go to state 63

state 46

    (28) exp -> lbrace . exp_list rbrace
    (29) exp_list -> . exp semi exp_list
    (30) exp_list -> . exp semi
    (17) exp -> . identifier larrow exp
    (18) exp -> . exp dot identifier lparen param_list rparen
    (19) exp -> . exp dot identifier lparen rparen
    (20) exp -> . exp at type dot identifier lparen param_list rparen
    (21) exp -> . exp at type dot identifier lparen rparen
    (22) exp -> . identifier lparen param_list rparen
    (23) exp -> . identifier lparen rparen
    (26) exp -> . if exp then exp else exp fi
    (27) exp -> . while exp loop exp pool
    (28) exp -> . lbrace exp_list rbrace
    (31) exp -> . let let_binding_list in exp
    (36) exp -> . case exp of case_elements esac
    (40) exp -> . new type
    (41) exp -> . isvoid exp
    (42) exp -> . exp plus exp
    (43) exp -> . exp minus exp
    (44) exp -> . exp times exp
    (45) exp -> . exp divide exp
    (46) exp -> . tilde exp
    (47) exp -> . exp lt exp
    (48) exp -> . exp le exp
    (49) exp -> . exp equals exp
    (50) exp -> . not exp
    (51) exp -> . lparen exp rparen
    (52) exp -> . identifier
    (53) exp -> . integer
    (54) exp -> . string
    (55) exp -> . true
    (56) exp -> . false

    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 47
    lbrace          shift and go to state 46
    let             shift and go to state 41
    case            shift and go to state 45
    new             shift and go to state 39
    isvoid          shift and go to state 38
    tilde           shift and go to state 35
    not             shift and go to state 43
    lparen          shift and go to state 42
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 44
    false           shift and go to state 34

    exp_list                       shift and go to state 64
    exp                            shift and go to state 65

state 47

    (27) exp -> while . exp loop exp pool
    (17) exp -> . identifier larrow exp
    (18) exp -> . exp dot identifier lparen param_list rparen
    (19) exp -> . exp dot identifier lparen rparen
    (20) exp -> . exp at type dot identifier lparen param_list rparen
    (21) exp -> . exp at type dot identifier lparen rparen
    (22) exp -> . identifier lparen param_list rparen
    (23) exp -> . identifier lparen rparen
    (26) exp -> . if exp then exp else exp fi
    (27) exp -> . while exp loop exp pool
    (28) exp -> . lbrace exp_list rbrace
    (31) exp -> . let let_binding_list in exp
    (36) exp -> . case exp of case_elements esac
    (40) exp -> . new type
    (41) exp -> . isvoid exp
    (42) exp -> . exp plus exp
    (43) exp -> . exp minus exp
    (44) exp -> . exp times exp
    (45) exp -> . exp divide exp
    (46) exp -> . tilde exp
    (47) exp -> . exp lt exp
    (48) exp -> . exp le exp
    (49) exp -> . exp equals exp
    (50) exp -> . not exp
    (51) exp -> . lparen exp rparen
    (52) exp -> . identifier
    (53) exp -> . integer
    (54) exp -> . string
    (55) exp -> . true
    (56) exp -> . false

    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 47
    lbrace          shift and go to state 46
    let             shift and go to state 41
    case            shift and go to state 45
    new             shift and go to state 39
    isvoid          shift and go to state 38
    tilde           shift and go to state 35
    not             shift and go to state 43
    lparen          shift and go to state 42
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 44
    false           shift and go to state 34

    exp                            shift and go to state 66

state 48

    (11) feature -> identifier colon type larrow exp .
    (18) exp -> exp . dot identifier lparen param_list rparen
    (19) exp -> exp . dot identifier lparen rparen
    (20) exp -> exp . at type dot identifier lparen param_list rparen
    (21) exp -> exp . at type dot identifier lparen rparen
    (42) exp -> exp . plus exp
    (43) exp -> exp . minus exp
    (44) exp -> exp . times exp
    (45) exp -> exp . divide exp
    (47) exp -> exp . lt exp
    (48) exp -> exp . le exp
    (49) exp -> exp . equals exp

    semi            reduce using rule 11 (feature -> identifier colon type larrow exp .)
    dot             shift and go to state 74
    at              shift and go to state 71
    plus            shift and go to state 72
    minus           shift and go to state 73
    times           shift and go to state 69
    divide          shift and go to state 75
    lt              shift and go to state 70
    le              shift and go to state 67
    equals          shift and go to state 68


state 49

    (17) exp -> identifier . larrow exp
    (22) exp -> identifier . lparen param_list rparen
    (23) exp -> identifier . lparen rparen
    (52) exp -> identifier .

    larrow          shift and go to state 76
    lparen          shift and go to state 77
    of              reduce using rule 52 (exp -> identifier .)
    dot             reduce using rule 52 (exp -> identifier .)
    at              reduce using rule 52 (exp -> identifier .)
    plus            reduce using rule 52 (exp -> identifier .)
    minus           reduce using rule 52 (exp -> identifier .)
    times           reduce using rule 52 (exp -> identifier .)
    divide          reduce using rule 52 (exp -> identifier .)
    lt              reduce using rule 52 (exp -> identifier .)
    le              reduce using rule 52 (exp -> identifier .)
    equals          reduce using rule 52 (exp -> identifier .)
    semi            reduce using rule 52 (exp -> identifier .)
    then            reduce using rule 52 (exp -> identifier .)
    rparen          reduce using rule 52 (exp -> identifier .)
    loop            reduce using rule 52 (exp -> identifier .)
    comma           reduce using rule 52 (exp -> identifier .)
    rbrace          reduce using rule 52 (exp -> identifier .)
    else            reduce using rule 52 (exp -> identifier .)
    pool            reduce using rule 52 (exp -> identifier .)
    fi              reduce using rule 52 (exp -> identifier .)
    in              reduce using rule 52 (exp -> identifier .)


state 50

    (13) feature -> identifier lparen rparen colon type . lbrace exp rbrace

    lbrace          shift and go to state 78


state 51

    (12) feature -> identifier lparen formal_list rparen colon . type lbrace exp rbrace

    type            shift and go to state 79


state 52

    (14) formal_list -> formal comma formal_list .

    rparen          reduce using rule 14 (formal_list -> formal comma formal_list .)


state 53

    (16) formal -> identifier colon type .

    comma           reduce using rule 16 (formal -> identifier colon type .)
    rparen          reduce using rule 16 (formal -> identifier colon type .)


state 54

    (46) exp -> tilde exp .
    (18) exp -> exp . dot identifier lparen param_list rparen
    (19) exp -> exp . dot identifier lparen rparen
    (20) exp -> exp . at type dot identifier lparen param_list rparen
    (21) exp -> exp . at type dot identifier lparen rparen
    (42) exp -> exp . plus exp
    (43) exp -> exp . minus exp
    (44) exp -> exp . times exp
    (45) exp -> exp . divide exp
    (47) exp -> exp . lt exp
    (48) exp -> exp . le exp
    (49) exp -> exp . equals exp

    of              reduce using rule 46 (exp -> tilde exp .)
    plus            reduce using rule 46 (exp -> tilde exp .)
    minus           reduce using rule 46 (exp -> tilde exp .)
    times           reduce using rule 46 (exp -> tilde exp .)
    divide          reduce using rule 46 (exp -> tilde exp .)
    lt              reduce using rule 46 (exp -> tilde exp .)
    le              reduce using rule 46 (exp -> tilde exp .)
    equals          reduce using rule 46 (exp -> tilde exp .)
    semi            reduce using rule 46 (exp -> tilde exp .)
    then            reduce using rule 46 (exp -> tilde exp .)
    rparen          reduce using rule 46 (exp -> tilde exp .)
    loop            reduce using rule 46 (exp -> tilde exp .)
    comma           reduce using rule 46 (exp -> tilde exp .)
    rbrace          reduce using rule 46 (exp -> tilde exp .)
    else            reduce using rule 46 (exp -> tilde exp .)
    pool            reduce using rule 46 (exp -> tilde exp .)
    fi              reduce using rule 46 (exp -> tilde exp .)
    in              reduce using rule 46 (exp -> tilde exp .)
    dot             shift and go to state 74
    at              shift and go to state 71

  ! dot             [ reduce using rule 46 (exp -> tilde exp .) ]
  ! at              [ reduce using rule 46 (exp -> tilde exp .) ]
  ! plus            [ shift and go to state 72 ]
  ! minus           [ shift and go to state 73 ]
  ! times           [ shift and go to state 69 ]
  ! divide          [ shift and go to state 75 ]
  ! lt              [ shift and go to state 70 ]
  ! le              [ shift and go to state 67 ]
  ! equals          [ shift and go to state 68 ]


state 55

    (26) exp -> if exp . then exp else exp fi
    (18) exp -> exp . dot identifier lparen param_list rparen
    (19) exp -> exp . dot identifier lparen rparen
    (20) exp -> exp . at type dot identifier lparen param_list rparen
    (21) exp -> exp . at type dot identifier lparen rparen
    (42) exp -> exp . plus exp
    (43) exp -> exp . minus exp
    (44) exp -> exp . times exp
    (45) exp -> exp . divide exp
    (47) exp -> exp . lt exp
    (48) exp -> exp . le exp
    (49) exp -> exp . equals exp

    then            shift and go to state 80
    dot             shift and go to state 74
    at              shift and go to state 71
    plus            shift and go to state 72
    minus           shift and go to state 73
    times           shift and go to state 69
    divide          shift and go to state 75
    lt              shift and go to state 70
    le              shift and go to state 67
    equals          shift and go to state 68


state 56

    (41) exp -> isvoid exp .
    (18) exp -> exp . dot identifier lparen param_list rparen
    (19) exp -> exp . dot identifier lparen rparen
    (20) exp -> exp . at type dot identifier lparen param_list rparen
    (21) exp -> exp . at type dot identifier lparen rparen
    (42) exp -> exp . plus exp
    (43) exp -> exp . minus exp
    (44) exp -> exp . times exp
    (45) exp -> exp . divide exp
    (47) exp -> exp . lt exp
    (48) exp -> exp . le exp
    (49) exp -> exp . equals exp

    of              reduce using rule 41 (exp -> isvoid exp .)
    plus            reduce using rule 41 (exp -> isvoid exp .)
    minus           reduce using rule 41 (exp -> isvoid exp .)
    times           reduce using rule 41 (exp -> isvoid exp .)
    divide          reduce using rule 41 (exp -> isvoid exp .)
    lt              reduce using rule 41 (exp -> isvoid exp .)
    le              reduce using rule 41 (exp -> isvoid exp .)
    equals          reduce using rule 41 (exp -> isvoid exp .)
    semi            reduce using rule 41 (exp -> isvoid exp .)
    then            reduce using rule 41 (exp -> isvoid exp .)
    rparen          reduce using rule 41 (exp -> isvoid exp .)
    loop            reduce using rule 41 (exp -> isvoid exp .)
    comma           reduce using rule 41 (exp -> isvoid exp .)
    rbrace          reduce using rule 41 (exp -> isvoid exp .)
    else            reduce using rule 41 (exp -> isvoid exp .)
    pool            reduce using rule 41 (exp -> isvoid exp .)
    fi              reduce using rule 41 (exp -> isvoid exp .)
    in              reduce using rule 41 (exp -> isvoid exp .)
    dot             shift and go to state 74
    at              shift and go to state 71

  ! dot             [ reduce using rule 41 (exp -> isvoid exp .) ]
  ! at              [ reduce using rule 41 (exp -> isvoid exp .) ]
  ! plus            [ shift and go to state 72 ]
  ! minus           [ shift and go to state 73 ]
  ! times           [ shift and go to state 69 ]
  ! divide          [ shift and go to state 75 ]
  ! lt              [ shift and go to state 70 ]
  ! le              [ shift and go to state 67 ]
  ! equals          [ shift and go to state 68 ]


state 57

    (40) exp -> new type .

    of              reduce using rule 40 (exp -> new type .)
    dot             reduce using rule 40 (exp -> new type .)
    at              reduce using rule 40 (exp -> new type .)
    plus            reduce using rule 40 (exp -> new type .)
    minus           reduce using rule 40 (exp -> new type .)
    times           reduce using rule 40 (exp -> new type .)
    divide          reduce using rule 40 (exp -> new type .)
    lt              reduce using rule 40 (exp -> new type .)
    le              reduce using rule 40 (exp -> new type .)
    equals          reduce using rule 40 (exp -> new type .)
    semi            reduce using rule 40 (exp -> new type .)
    then            reduce using rule 40 (exp -> new type .)
    rparen          reduce using rule 40 (exp -> new type .)
    loop            reduce using rule 40 (exp -> new type .)
    comma           reduce using rule 40 (exp -> new type .)
    rbrace          reduce using rule 40 (exp -> new type .)
    else            reduce using rule 40 (exp -> new type .)
    pool            reduce using rule 40 (exp -> new type .)
    fi              reduce using rule 40 (exp -> new type .)
    in              reduce using rule 40 (exp -> new type .)


state 58

    (31) exp -> let let_binding_list . in exp

    in              shift and go to state 81


state 59

    (32) let_binding_list -> let_binding . comma let_binding_list
    (33) let_binding_list -> let_binding .

    comma           shift and go to state 82
    in              reduce using rule 33 (let_binding_list -> let_binding .)


state 60

    (34) let_binding -> identifier . colon type
    (35) let_binding -> identifier . colon type larrow exp

    colon           shift and go to state 83


state 61

    (51) exp -> lparen exp . rparen
    (18) exp -> exp . dot identifier lparen param_list rparen
    (19) exp -> exp . dot identifier lparen rparen
    (20) exp -> exp . at type dot identifier lparen param_list rparen
    (21) exp -> exp . at type dot identifier lparen rparen
    (42) exp -> exp . plus exp
    (43) exp -> exp . minus exp
    (44) exp -> exp . times exp
    (45) exp -> exp . divide exp
    (47) exp -> exp . lt exp
    (48) exp -> exp . le exp
    (49) exp -> exp . equals exp

    rparen          shift and go to state 84
    dot             shift and go to state 74
    at              shift and go to state 71
    plus            shift and go to state 72
    minus           shift and go to state 73
    times           shift and go to state 69
    divide          shift and go to state 75
    lt              shift and go to state 70
    le              shift and go to state 67
    equals          shift and go to state 68


state 62

    (50) exp -> not exp .
    (18) exp -> exp . dot identifier lparen param_list rparen
    (19) exp -> exp . dot identifier lparen rparen
    (20) exp -> exp . at type dot identifier lparen param_list rparen
    (21) exp -> exp . at type dot identifier lparen rparen
    (42) exp -> exp . plus exp
    (43) exp -> exp . minus exp
    (44) exp -> exp . times exp
    (45) exp -> exp . divide exp
    (47) exp -> exp . lt exp
    (48) exp -> exp . le exp
    (49) exp -> exp . equals exp

    of              reduce using rule 50 (exp -> not exp .)
    semi            reduce using rule 50 (exp -> not exp .)
    then            reduce using rule 50 (exp -> not exp .)
    rparen          reduce using rule 50 (exp -> not exp .)
    loop            reduce using rule 50 (exp -> not exp .)
    comma           reduce using rule 50 (exp -> not exp .)
    rbrace          reduce using rule 50 (exp -> not exp .)
    else            reduce using rule 50 (exp -> not exp .)
    pool            reduce using rule 50 (exp -> not exp .)
    fi              reduce using rule 50 (exp -> not exp .)
    in              reduce using rule 50 (exp -> not exp .)
    dot             shift and go to state 74
    at              shift and go to state 71
    plus            shift and go to state 72
    minus           shift and go to state 73
    times           shift and go to state 69
    divide          shift and go to state 75
    lt              shift and go to state 70
    le              shift and go to state 67
    equals          shift and go to state 68

  ! dot             [ reduce using rule 50 (exp -> not exp .) ]
  ! at              [ reduce using rule 50 (exp -> not exp .) ]
  ! plus            [ reduce using rule 50 (exp -> not exp .) ]
  ! minus           [ reduce using rule 50 (exp -> not exp .) ]
  ! times           [ reduce using rule 50 (exp -> not exp .) ]
  ! divide          [ reduce using rule 50 (exp -> not exp .) ]
  ! lt              [ reduce using rule 50 (exp -> not exp .) ]
  ! le              [ reduce using rule 50 (exp -> not exp .) ]
  ! equals          [ reduce using rule 50 (exp -> not exp .) ]


state 63

    (36) exp -> case exp . of case_elements esac
    (18) exp -> exp . dot identifier lparen param_list rparen
    (19) exp -> exp . dot identifier lparen rparen
    (20) exp -> exp . at type dot identifier lparen param_list rparen
    (21) exp -> exp . at type dot identifier lparen rparen
    (42) exp -> exp . plus exp
    (43) exp -> exp . minus exp
    (44) exp -> exp . times exp
    (45) exp -> exp . divide exp
    (47) exp -> exp . lt exp
    (48) exp -> exp . le exp
    (49) exp -> exp . equals exp

    of              shift and go to state 85
    dot             shift and go to state 74
    at              shift and go to state 71
    plus            shift and go to state 72
    minus           shift and go to state 73
    times           shift and go to state 69
    divide          shift and go to state 75
    lt              shift and go to state 70
    le              shift and go to state 67
    equals          shift and go to state 68


state 64

    (28) exp -> lbrace exp_list . rbrace

    rbrace          shift and go to state 86


state 65

    (29) exp_list -> exp . semi exp_list
    (30) exp_list -> exp . semi
    (18) exp -> exp . dot identifier lparen param_list rparen
    (19) exp -> exp . dot identifier lparen rparen
    (20) exp -> exp . at type dot identifier lparen param_list rparen
    (21) exp -> exp . at type dot identifier lparen rparen
    (42) exp -> exp . plus exp
    (43) exp -> exp . minus exp
    (44) exp -> exp . times exp
    (45) exp -> exp . divide exp
    (47) exp -> exp . lt exp
    (48) exp -> exp . le exp
    (49) exp -> exp . equals exp

    semi            shift and go to state 87
    dot             shift and go to state 74
    at              shift and go to state 71
    plus            shift and go to state 72
    minus           shift and go to state 73
    times           shift and go to state 69
    divide          shift and go to state 75
    lt              shift and go to state 70
    le              shift and go to state 67
    equals          shift and go to state 68


state 66

    (27) exp -> while exp . loop exp pool
    (18) exp -> exp . dot identifier lparen param_list rparen
    (19) exp -> exp . dot identifier lparen rparen
    (20) exp -> exp . at type dot identifier lparen param_list rparen
    (21) exp -> exp . at type dot identifier lparen rparen
    (42) exp -> exp . plus exp
    (43) exp -> exp . minus exp
    (44) exp -> exp . times exp
    (45) exp -> exp . divide exp
    (47) exp -> exp . lt exp
    (48) exp -> exp . le exp
    (49) exp -> exp . equals exp

    loop            shift and go to state 88
    dot             shift and go to state 74
    at              shift and go to state 71
    plus            shift and go to state 72
    minus           shift and go to state 73
    times           shift and go to state 69
    divide          shift and go to state 75
    lt              shift and go to state 70
    le              shift and go to state 67
    equals          shift and go to state 68


state 67

    (48) exp -> exp le . exp
    (17) exp -> . identifier larrow exp
    (18) exp -> . exp dot identifier lparen param_list rparen
    (19) exp -> . exp dot identifier lparen rparen
    (20) exp -> . exp at type dot identifier lparen param_list rparen
    (21) exp -> . exp at type dot identifier lparen rparen
    (22) exp -> . identifier lparen param_list rparen
    (23) exp -> . identifier lparen rparen
    (26) exp -> . if exp then exp else exp fi
    (27) exp -> . while exp loop exp pool
    (28) exp -> . lbrace exp_list rbrace
    (31) exp -> . let let_binding_list in exp
    (36) exp -> . case exp of case_elements esac
    (40) exp -> . new type
    (41) exp -> . isvoid exp
    (42) exp -> . exp plus exp
    (43) exp -> . exp minus exp
    (44) exp -> . exp times exp
    (45) exp -> . exp divide exp
    (46) exp -> . tilde exp
    (47) exp -> . exp lt exp
    (48) exp -> . exp le exp
    (49) exp -> . exp equals exp
    (50) exp -> . not exp
    (51) exp -> . lparen exp rparen
    (52) exp -> . identifier
    (53) exp -> . integer
    (54) exp -> . string
    (55) exp -> . true
    (56) exp -> . false

    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 47
    lbrace          shift and go to state 46
    let             shift and go to state 41
    case            shift and go to state 45
    new             shift and go to state 39
    isvoid          shift and go to state 38
    tilde           shift and go to state 35
    not             shift and go to state 43
    lparen          shift and go to state 42
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 44
    false           shift and go to state 34

    exp                            shift and go to state 89

state 68

    (49) exp -> exp equals . exp
    (17) exp -> . identifier larrow exp
    (18) exp -> . exp dot identifier lparen param_list rparen
    (19) exp -> . exp dot identifier lparen rparen
    (20) exp -> . exp at type dot identifier lparen param_list rparen
    (21) exp -> . exp at type dot identifier lparen rparen
    (22) exp -> . identifier lparen param_list rparen
    (23) exp -> . identifier lparen rparen
    (26) exp -> . if exp then exp else exp fi
    (27) exp -> . while exp loop exp pool
    (28) exp -> . lbrace exp_list rbrace
    (31) exp -> . let let_binding_list in exp
    (36) exp -> . case exp of case_elements esac
    (40) exp -> . new type
    (41) exp -> . isvoid exp
    (42) exp -> . exp plus exp
    (43) exp -> . exp minus exp
    (44) exp -> . exp times exp
    (45) exp -> . exp divide exp
    (46) exp -> . tilde exp
    (47) exp -> . exp lt exp
    (48) exp -> . exp le exp
    (49) exp -> . exp equals exp
    (50) exp -> . not exp
    (51) exp -> . lparen exp rparen
    (52) exp -> . identifier
    (53) exp -> . integer
    (54) exp -> . string
    (55) exp -> . true
    (56) exp -> . false

    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 47
    lbrace          shift and go to state 46
    let             shift and go to state 41
    case            shift and go to state 45
    new             shift and go to state 39
    isvoid          shift and go to state 38
    tilde           shift and go to state 35
    not             shift and go to state 43
    lparen          shift and go to state 42
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 44
    false           shift and go to state 34

    exp                            shift and go to state 90

state 69

    (44) exp -> exp times . exp
    (17) exp -> . identifier larrow exp
    (18) exp -> . exp dot identifier lparen param_list rparen
    (19) exp -> . exp dot identifier lparen rparen
    (20) exp -> . exp at type dot identifier lparen param_list rparen
    (21) exp -> . exp at type dot identifier lparen rparen
    (22) exp -> . identifier lparen param_list rparen
    (23) exp -> . identifier lparen rparen
    (26) exp -> . if exp then exp else exp fi
    (27) exp -> . while exp loop exp pool
    (28) exp -> . lbrace exp_list rbrace
    (31) exp -> . let let_binding_list in exp
    (36) exp -> . case exp of case_elements esac
    (40) exp -> . new type
    (41) exp -> . isvoid exp
    (42) exp -> . exp plus exp
    (43) exp -> . exp minus exp
    (44) exp -> . exp times exp
    (45) exp -> . exp divide exp
    (46) exp -> . tilde exp
    (47) exp -> . exp lt exp
    (48) exp -> . exp le exp
    (49) exp -> . exp equals exp
    (50) exp -> . not exp
    (51) exp -> . lparen exp rparen
    (52) exp -> . identifier
    (53) exp -> . integer
    (54) exp -> . string
    (55) exp -> . true
    (56) exp -> . false

    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 47
    lbrace          shift and go to state 46
    let             shift and go to state 41
    case            shift and go to state 45
    new             shift and go to state 39
    isvoid          shift and go to state 38
    tilde           shift and go to state 35
    not             shift and go to state 43
    lparen          shift and go to state 42
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 44
    false           shift and go to state 34

    exp                            shift and go to state 91

state 70

    (47) exp -> exp lt . exp
    (17) exp -> . identifier larrow exp
    (18) exp -> . exp dot identifier lparen param_list rparen
    (19) exp -> . exp dot identifier lparen rparen
    (20) exp -> . exp at type dot identifier lparen param_list rparen
    (21) exp -> . exp at type dot identifier lparen rparen
    (22) exp -> . identifier lparen param_list rparen
    (23) exp -> . identifier lparen rparen
    (26) exp -> . if exp then exp else exp fi
    (27) exp -> . while exp loop exp pool
    (28) exp -> . lbrace exp_list rbrace
    (31) exp -> . let let_binding_list in exp
    (36) exp -> . case exp of case_elements esac
    (40) exp -> . new type
    (41) exp -> . isvoid exp
    (42) exp -> . exp plus exp
    (43) exp -> . exp minus exp
    (44) exp -> . exp times exp
    (45) exp -> . exp divide exp
    (46) exp -> . tilde exp
    (47) exp -> . exp lt exp
    (48) exp -> . exp le exp
    (49) exp -> . exp equals exp
    (50) exp -> . not exp
    (51) exp -> . lparen exp rparen
    (52) exp -> . identifier
    (53) exp -> . integer
    (54) exp -> . string
    (55) exp -> . true
    (56) exp -> . false

    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 47
    lbrace          shift and go to state 46
    let             shift and go to state 41
    case            shift and go to state 45
    new             shift and go to state 39
    isvoid          shift and go to state 38
    tilde           shift and go to state 35
    not             shift and go to state 43
    lparen          shift and go to state 42
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 44
    false           shift and go to state 34

    exp                            shift and go to state 92

state 71

    (20) exp -> exp at . type dot identifier lparen param_list rparen
    (21) exp -> exp at . type dot identifier lparen rparen

    type            shift and go to state 93


state 72

    (42) exp -> exp plus . exp
    (17) exp -> . identifier larrow exp
    (18) exp -> . exp dot identifier lparen param_list rparen
    (19) exp -> . exp dot identifier lparen rparen
    (20) exp -> . exp at type dot identifier lparen param_list rparen
    (21) exp -> . exp at type dot identifier lparen rparen
    (22) exp -> . identifier lparen param_list rparen
    (23) exp -> . identifier lparen rparen
    (26) exp -> . if exp then exp else exp fi
    (27) exp -> . while exp loop exp pool
    (28) exp -> . lbrace exp_list rbrace
    (31) exp -> . let let_binding_list in exp
    (36) exp -> . case exp of case_elements esac
    (40) exp -> . new type
    (41) exp -> . isvoid exp
    (42) exp -> . exp plus exp
    (43) exp -> . exp minus exp
    (44) exp -> . exp times exp
    (45) exp -> . exp divide exp
    (46) exp -> . tilde exp
    (47) exp -> . exp lt exp
    (48) exp -> . exp le exp
    (49) exp -> . exp equals exp
    (50) exp -> . not exp
    (51) exp -> . lparen exp rparen
    (52) exp -> . identifier
    (53) exp -> . integer
    (54) exp -> . string
    (55) exp -> . true
    (56) exp -> . false

    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 47
    lbrace          shift and go to state 46
    let             shift and go to state 41
    case            shift and go to state 45
    new             shift and go to state 39
    isvoid          shift and go to state 38
    tilde           shift and go to state 35
    not             shift and go to state 43
    lparen          shift and go to state 42
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 44
    false           shift and go to state 34

    exp                            shift and go to state 94

state 73

    (43) exp -> exp minus . exp
    (17) exp -> . identifier larrow exp
    (18) exp -> . exp dot identifier lparen param_list rparen
    (19) exp -> . exp dot identifier lparen rparen
    (20) exp -> . exp at type dot identifier lparen param_list rparen
    (21) exp -> . exp at type dot identifier lparen rparen
    (22) exp -> . identifier lparen param_list rparen
    (23) exp -> . identifier lparen rparen
    (26) exp -> . if exp then exp else exp fi
    (27) exp -> . while exp loop exp pool
    (28) exp -> . lbrace exp_list rbrace
    (31) exp -> . let let_binding_list in exp
    (36) exp -> . case exp of case_elements esac
    (40) exp -> . new type
    (41) exp -> . isvoid exp
    (42) exp -> . exp plus exp
    (43) exp -> . exp minus exp
    (44) exp -> . exp times exp
    (45) exp -> . exp divide exp
    (46) exp -> . tilde exp
    (47) exp -> . exp lt exp
    (48) exp -> . exp le exp
    (49) exp -> . exp equals exp
    (50) exp -> . not exp
    (51) exp -> . lparen exp rparen
    (52) exp -> . identifier
    (53) exp -> . integer
    (54) exp -> . string
    (55) exp -> . true
    (56) exp -> . false

    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 47
    lbrace          shift and go to state 46
    let             shift and go to state 41
    case            shift and go to state 45
    new             shift and go to state 39
    isvoid          shift and go to state 38
    tilde           shift and go to state 35
    not             shift and go to state 43
    lparen          shift and go to state 42
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 44
    false           shift and go to state 34

    exp                            shift and go to state 95

state 74

    (18) exp -> exp dot . identifier lparen param_list rparen
    (19) exp -> exp dot . identifier lparen rparen

    identifier      shift and go to state 96


state 75

    (45) exp -> exp divide . exp
    (17) exp -> . identifier larrow exp
    (18) exp -> . exp dot identifier lparen param_list rparen
    (19) exp -> . exp dot identifier lparen rparen
    (20) exp -> . exp at type dot identifier lparen param_list rparen
    (21) exp -> . exp at type dot identifier lparen rparen
    (22) exp -> . identifier lparen param_list rparen
    (23) exp -> . identifier lparen rparen
    (26) exp -> . if exp then exp else exp fi
    (27) exp -> . while exp loop exp pool
    (28) exp -> . lbrace exp_list rbrace
    (31) exp -> . let let_binding_list in exp
    (36) exp -> . case exp of case_elements esac
    (40) exp -> . new type
    (41) exp -> . isvoid exp
    (42) exp -> . exp plus exp
    (43) exp -> . exp minus exp
    (44) exp -> . exp times exp
    (45) exp -> . exp divide exp
    (46) exp -> . tilde exp
    (47) exp -> . exp lt exp
    (48) exp -> . exp le exp
    (49) exp -> . exp equals exp
    (50) exp -> . not exp
    (51) exp -> . lparen exp rparen
    (52) exp -> . identifier
    (53) exp -> . integer
    (54) exp -> . string
    (55) exp -> . true
    (56) exp -> . false

    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 47
    lbrace          shift and go to state 46
    let             shift and go to state 41
    case            shift and go to state 45
    new             shift and go to state 39
    isvoid          shift and go to state 38
    tilde           shift and go to state 35
    not             shift and go to state 43
    lparen          shift and go to state 42
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 44
    false           shift and go to state 34

    exp                            shift and go to state 97

state 76

    (17) exp -> identifier larrow . exp
    (17) exp -> . identifier larrow exp
    (18) exp -> . exp dot identifier lparen param_list rparen
    (19) exp -> . exp dot identifier lparen rparen
    (20) exp -> . exp at type dot identifier lparen param_list rparen
    (21) exp -> . exp at type dot identifier lparen rparen
    (22) exp -> . identifier lparen param_list rparen
    (23) exp -> . identifier lparen rparen
    (26) exp -> . if exp then exp else exp fi
    (27) exp -> . while exp loop exp pool
    (28) exp -> . lbrace exp_list rbrace
    (31) exp -> . let let_binding_list in exp
    (36) exp -> . case exp of case_elements esac
    (40) exp -> . new type
    (41) exp -> . isvoid exp
    (42) exp -> . exp plus exp
    (43) exp -> . exp minus exp
    (44) exp -> . exp times exp
    (45) exp -> . exp divide exp
    (46) exp -> . tilde exp
    (47) exp -> . exp lt exp
    (48) exp -> . exp le exp
    (49) exp -> . exp equals exp
    (50) exp -> . not exp
    (51) exp -> . lparen exp rparen
    (52) exp -> . identifier
    (53) exp -> . integer
    (54) exp -> . string
    (55) exp -> . true
    (56) exp -> . false

    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 47
    lbrace          shift and go to state 46
    let             shift and go to state 41
    case            shift and go to state 45
    new             shift and go to state 39
    isvoid          shift and go to state 38
    tilde           shift and go to state 35
    not             shift and go to state 43
    lparen          shift and go to state 42
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 44
    false           shift and go to state 34

    exp                            shift and go to state 98

state 77

    (22) exp -> identifier lparen . param_list rparen
    (23) exp -> identifier lparen . rparen
    (24) param_list -> . exp comma param_list
    (25) param_list -> . exp
    (17) exp -> . identifier larrow exp
    (18) exp -> . exp dot identifier lparen param_list rparen
    (19) exp -> . exp dot identifier lparen rparen
    (20) exp -> . exp at type dot identifier lparen param_list rparen
    (21) exp -> . exp at type dot identifier lparen rparen
    (22) exp -> . identifier lparen param_list rparen
    (23) exp -> . identifier lparen rparen
    (26) exp -> . if exp then exp else exp fi
    (27) exp -> . while exp loop exp pool
    (28) exp -> . lbrace exp_list rbrace
    (31) exp -> . let let_binding_list in exp
    (36) exp -> . case exp of case_elements esac
    (40) exp -> . new type
    (41) exp -> . isvoid exp
    (42) exp -> . exp plus exp
    (43) exp -> . exp minus exp
    (44) exp -> . exp times exp
    (45) exp -> . exp divide exp
    (46) exp -> . tilde exp
    (47) exp -> . exp lt exp
    (48) exp -> . exp le exp
    (49) exp -> . exp equals exp
    (50) exp -> . not exp
    (51) exp -> . lparen exp rparen
    (52) exp -> . identifier
    (53) exp -> . integer
    (54) exp -> . string
    (55) exp -> . true
    (56) exp -> . false

    rparen          shift and go to state 100
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 47
    lbrace          shift and go to state 46
    let             shift and go to state 41
    case            shift and go to state 45
    new             shift and go to state 39
    isvoid          shift and go to state 38
    tilde           shift and go to state 35
    not             shift and go to state 43
    lparen          shift and go to state 42
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 44
    false           shift and go to state 34

    param_list                     shift and go to state 99
    exp                            shift and go to state 101

state 78

    (13) feature -> identifier lparen rparen colon type lbrace . exp rbrace
    (17) exp -> . identifier larrow exp
    (18) exp -> . exp dot identifier lparen param_list rparen
    (19) exp -> . exp dot identifier lparen rparen
    (20) exp -> . exp at type dot identifier lparen param_list rparen
    (21) exp -> . exp at type dot identifier lparen rparen
    (22) exp -> . identifier lparen param_list rparen
    (23) exp -> . identifier lparen rparen
    (26) exp -> . if exp then exp else exp fi
    (27) exp -> . while exp loop exp pool
    (28) exp -> . lbrace exp_list rbrace
    (31) exp -> . let let_binding_list in exp
    (36) exp -> . case exp of case_elements esac
    (40) exp -> . new type
    (41) exp -> . isvoid exp
    (42) exp -> . exp plus exp
    (43) exp -> . exp minus exp
    (44) exp -> . exp times exp
    (45) exp -> . exp divide exp
    (46) exp -> . tilde exp
    (47) exp -> . exp lt exp
    (48) exp -> . exp le exp
    (49) exp -> . exp equals exp
    (50) exp -> . not exp
    (51) exp -> . lparen exp rparen
    (52) exp -> . identifier
    (53) exp -> . integer
    (54) exp -> . string
    (55) exp -> . true
    (56) exp -> . false

    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 47
    lbrace          shift and go to state 46
    let             shift and go to state 41
    case            shift and go to state 45
    new             shift and go to state 39
    isvoid          shift and go to state 38
    tilde           shift and go to state 35
    not             shift and go to state 43
    lparen          shift and go to state 42
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 44
    false           shift and go to state 34

    exp                            shift and go to state 102

state 79

    (12) feature -> identifier lparen formal_list rparen colon type . lbrace exp rbrace

    lbrace          shift and go to state 103


state 80

    (26) exp -> if exp then . exp else exp fi
    (17) exp -> . identifier larrow exp
    (18) exp -> . exp dot identifier lparen param_list rparen
    (19) exp -> . exp dot identifier lparen rparen
    (20) exp -> . exp at type dot identifier lparen param_list rparen
    (21) exp -> . exp at type dot identifier lparen rparen
    (22) exp -> . identifier lparen param_list rparen
    (23) exp -> . identifier lparen rparen
    (26) exp -> . if exp then exp else exp fi
    (27) exp -> . while exp loop exp pool
    (28) exp -> . lbrace exp_list rbrace
    (31) exp -> . let let_binding_list in exp
    (36) exp -> . case exp of case_elements esac
    (40) exp -> . new type
    (41) exp -> . isvoid exp
    (42) exp -> . exp plus exp
    (43) exp -> . exp minus exp
    (44) exp -> . exp times exp
    (45) exp -> . exp divide exp
    (46) exp -> . tilde exp
    (47) exp -> . exp lt exp
    (48) exp -> . exp le exp
    (49) exp -> . exp equals exp
    (50) exp -> . not exp
    (51) exp -> . lparen exp rparen
    (52) exp -> . identifier
    (53) exp -> . integer
    (54) exp -> . string
    (55) exp -> . true
    (56) exp -> . false

    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 47
    lbrace          shift and go to state 46
    let             shift and go to state 41
    case            shift and go to state 45
    new             shift and go to state 39
    isvoid          shift and go to state 38
    tilde           shift and go to state 35
    not             shift and go to state 43
    lparen          shift and go to state 42
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 44
    false           shift and go to state 34

    exp                            shift and go to state 104

state 81

    (31) exp -> let let_binding_list in . exp
    (17) exp -> . identifier larrow exp
    (18) exp -> . exp dot identifier lparen param_list rparen
    (19) exp -> . exp dot identifier lparen rparen
    (20) exp -> . exp at type dot identifier lparen param_list rparen
    (21) exp -> . exp at type dot identifier lparen rparen
    (22) exp -> . identifier lparen param_list rparen
    (23) exp -> . identifier lparen rparen
    (26) exp -> . if exp then exp else exp fi
    (27) exp -> . while exp loop exp pool
    (28) exp -> . lbrace exp_list rbrace
    (31) exp -> . let let_binding_list in exp
    (36) exp -> . case exp of case_elements esac
    (40) exp -> . new type
    (41) exp -> . isvoid exp
    (42) exp -> . exp plus exp
    (43) exp -> . exp minus exp
    (44) exp -> . exp times exp
    (45) exp -> . exp divide exp
    (46) exp -> . tilde exp
    (47) exp -> . exp lt exp
    (48) exp -> . exp le exp
    (49) exp -> . exp equals exp
    (50) exp -> . not exp
    (51) exp -> . lparen exp rparen
    (52) exp -> . identifier
    (53) exp -> . integer
    (54) exp -> . string
    (55) exp -> . true
    (56) exp -> . false

    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 47
    lbrace          shift and go to state 46
    let             shift and go to state 41
    case            shift and go to state 45
    new             shift and go to state 39
    isvoid          shift and go to state 38
    tilde           shift and go to state 35
    not             shift and go to state 43
    lparen          shift and go to state 42
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 44
    false           shift and go to state 34

    exp                            shift and go to state 105

state 82

    (32) let_binding_list -> let_binding comma . let_binding_list
    (32) let_binding_list -> . let_binding comma let_binding_list
    (33) let_binding_list -> . let_binding
    (34) let_binding -> . identifier colon type
    (35) let_binding -> . identifier colon type larrow exp

    identifier      shift and go to state 60

    let_binding                    shift and go to state 59
    let_binding_list               shift and go to state 106

state 83

    (34) let_binding -> identifier colon . type
    (35) let_binding -> identifier colon . type larrow exp

    type            shift and go to state 107


state 84

    (51) exp -> lparen exp rparen .

    of              reduce using rule 51 (exp -> lparen exp rparen .)
    dot             reduce using rule 51 (exp -> lparen exp rparen .)
    at              reduce using rule 51 (exp -> lparen exp rparen .)
    plus            reduce using rule 51 (exp -> lparen exp rparen .)
    minus           reduce using rule 51 (exp -> lparen exp rparen .)
    times           reduce using rule 51 (exp -> lparen exp rparen .)
    divide          reduce using rule 51 (exp -> lparen exp rparen .)
    lt              reduce using rule 51 (exp -> lparen exp rparen .)
    le              reduce using rule 51 (exp -> lparen exp rparen .)
    equals          reduce using rule 51 (exp -> lparen exp rparen .)
    semi            reduce using rule 51 (exp -> lparen exp rparen .)
    then            reduce using rule 51 (exp -> lparen exp rparen .)
    rparen          reduce using rule 51 (exp -> lparen exp rparen .)
    loop            reduce using rule 51 (exp -> lparen exp rparen .)
    comma           reduce using rule 51 (exp -> lparen exp rparen .)
    rbrace          reduce using rule 51 (exp -> lparen exp rparen .)
    else            reduce using rule 51 (exp -> lparen exp rparen .)
    pool            reduce using rule 51 (exp -> lparen exp rparen .)
    fi              reduce using rule 51 (exp -> lparen exp rparen .)
    in              reduce using rule 51 (exp -> lparen exp rparen .)


state 85

    (36) exp -> case exp of . case_elements esac
    (37) case_elements -> . case_element semi case_elements
    (38) case_elements -> . case_element semi
    (39) case_element -> . identifier colon type rarrow exp

    identifier      shift and go to state 109

    case_elements                  shift and go to state 110
    case_element                   shift and go to state 108

state 86

    (28) exp -> lbrace exp_list rbrace .

    of              reduce using rule 28 (exp -> lbrace exp_list rbrace .)
    dot             reduce using rule 28 (exp -> lbrace exp_list rbrace .)
    at              reduce using rule 28 (exp -> lbrace exp_list rbrace .)
    plus            reduce using rule 28 (exp -> lbrace exp_list rbrace .)
    minus           reduce using rule 28 (exp -> lbrace exp_list rbrace .)
    times           reduce using rule 28 (exp -> lbrace exp_list rbrace .)
    divide          reduce using rule 28 (exp -> lbrace exp_list rbrace .)
    lt              reduce using rule 28 (exp -> lbrace exp_list rbrace .)
    le              reduce using rule 28 (exp -> lbrace exp_list rbrace .)
    equals          reduce using rule 28 (exp -> lbrace exp_list rbrace .)
    semi            reduce using rule 28 (exp -> lbrace exp_list rbrace .)
    then            reduce using rule 28 (exp -> lbrace exp_list rbrace .)
    rparen          reduce using rule 28 (exp -> lbrace exp_list rbrace .)
    loop            reduce using rule 28 (exp -> lbrace exp_list rbrace .)
    comma           reduce using rule 28 (exp -> lbrace exp_list rbrace .)
    rbrace          reduce using rule 28 (exp -> lbrace exp_list rbrace .)
    else            reduce using rule 28 (exp -> lbrace exp_list rbrace .)
    pool            reduce using rule 28 (exp -> lbrace exp_list rbrace .)
    fi              reduce using rule 28 (exp -> lbrace exp_list rbrace .)
    in              reduce using rule 28 (exp -> lbrace exp_list rbrace .)


state 87

    (29) exp_list -> exp semi . exp_list
    (30) exp_list -> exp semi .
    (29) exp_list -> . exp semi exp_list
    (30) exp_list -> . exp semi
    (17) exp -> . identifier larrow exp
    (18) exp -> . exp dot identifier lparen param_list rparen
    (19) exp -> . exp dot identifier lparen rparen
    (20) exp -> . exp at type dot identifier lparen param_list rparen
    (21) exp -> . exp at type dot identifier lparen rparen
    (22) exp -> . identifier lparen param_list rparen
    (23) exp -> . identifier lparen rparen
    (26) exp -> . if exp then exp else exp fi
    (27) exp -> . while exp loop exp pool
    (28) exp -> . lbrace exp_list rbrace
    (31) exp -> . let let_binding_list in exp
    (36) exp -> . case exp of case_elements esac
    (40) exp -> . new type
    (41) exp -> . isvoid exp
    (42) exp -> . exp plus exp
    (43) exp -> . exp minus exp
    (44) exp -> . exp times exp
    (45) exp -> . exp divide exp
    (46) exp -> . tilde exp
    (47) exp -> . exp lt exp
    (48) exp -> . exp le exp
    (49) exp -> . exp equals exp
    (50) exp -> . not exp
    (51) exp -> . lparen exp rparen
    (52) exp -> . identifier
    (53) exp -> . integer
    (54) exp -> . string
    (55) exp -> . true
    (56) exp -> . false

    rbrace          reduce using rule 30 (exp_list -> exp semi .)
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 47
    lbrace          shift and go to state 46
    let             shift and go to state 41
    case            shift and go to state 45
    new             shift and go to state 39
    isvoid          shift and go to state 38
    tilde           shift and go to state 35
    not             shift and go to state 43
    lparen          shift and go to state 42
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 44
    false           shift and go to state 34

    exp_list                       shift and go to state 111
    exp                            shift and go to state 65

state 88

    (27) exp -> while exp loop . exp pool
    (17) exp -> . identifier larrow exp
    (18) exp -> . exp dot identifier lparen param_list rparen
    (19) exp -> . exp dot identifier lparen rparen
    (20) exp -> . exp at type dot identifier lparen param_list rparen
    (21) exp -> . exp at type dot identifier lparen rparen
    (22) exp -> . identifier lparen param_list rparen
    (23) exp -> . identifier lparen rparen
    (26) exp -> . if exp then exp else exp fi
    (27) exp -> . while exp loop exp pool
    (28) exp -> . lbrace exp_list rbrace
    (31) exp -> . let let_binding_list in exp
    (36) exp -> . case exp of case_elements esac
    (40) exp -> . new type
    (41) exp -> . isvoid exp
    (42) exp -> . exp plus exp
    (43) exp -> . exp minus exp
    (44) exp -> . exp times exp
    (45) exp -> . exp divide exp
    (46) exp -> . tilde exp
    (47) exp -> . exp lt exp
    (48) exp -> . exp le exp
    (49) exp -> . exp equals exp
    (50) exp -> . not exp
    (51) exp -> . lparen exp rparen
    (52) exp -> . identifier
    (53) exp -> . integer
    (54) exp -> . string
    (55) exp -> . true
    (56) exp -> . false

    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 47
    lbrace          shift and go to state 46
    let             shift and go to state 41
    case            shift and go to state 45
    new             shift and go to state 39
    isvoid          shift and go to state 38
    tilde           shift and go to state 35
    not             shift and go to state 43
    lparen          shift and go to state 42
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 44
    false           shift and go to state 34

    exp                            shift and go to state 112

state 89

    (48) exp -> exp le exp .
    (18) exp -> exp . dot identifier lparen param_list rparen
    (19) exp -> exp . dot identifier lparen rparen
    (20) exp -> exp . at type dot identifier lparen param_list rparen
    (21) exp -> exp . at type dot identifier lparen rparen
    (42) exp -> exp . plus exp
    (43) exp -> exp . minus exp
    (44) exp -> exp . times exp
    (45) exp -> exp . divide exp
    (47) exp -> exp . lt exp
    (48) exp -> exp . le exp
    (49) exp -> exp . equals exp

    of              reduce using rule 48 (exp -> exp le exp .)
    lt              reduce using rule 48 (exp -> exp le exp .)
    le              reduce using rule 48 (exp -> exp le exp .)
    equals          reduce using rule 48 (exp -> exp le exp .)
    semi            reduce using rule 48 (exp -> exp le exp .)
    then            reduce using rule 48 (exp -> exp le exp .)
    rparen          reduce using rule 48 (exp -> exp le exp .)
    loop            reduce using rule 48 (exp -> exp le exp .)
    comma           reduce using rule 48 (exp -> exp le exp .)
    rbrace          reduce using rule 48 (exp -> exp le exp .)
    else            reduce using rule 48 (exp -> exp le exp .)
    pool            reduce using rule 48 (exp -> exp le exp .)
    fi              reduce using rule 48 (exp -> exp le exp .)
    in              reduce using rule 48 (exp -> exp le exp .)
    dot             shift and go to state 74
    at              shift and go to state 71
    plus            shift and go to state 72
    minus           shift and go to state 73
    times           shift and go to state 69
    divide          shift and go to state 75

  ! dot             [ reduce using rule 48 (exp -> exp le exp .) ]
  ! at              [ reduce using rule 48 (exp -> exp le exp .) ]
  ! plus            [ reduce using rule 48 (exp -> exp le exp .) ]
  ! minus           [ reduce using rule 48 (exp -> exp le exp .) ]
  ! times           [ reduce using rule 48 (exp -> exp le exp .) ]
  ! divide          [ reduce using rule 48 (exp -> exp le exp .) ]
  ! lt              [ shift and go to state 70 ]
  ! le              [ shift and go to state 67 ]
  ! equals          [ shift and go to state 68 ]


state 90

    (49) exp -> exp equals exp .
    (18) exp -> exp . dot identifier lparen param_list rparen
    (19) exp -> exp . dot identifier lparen rparen
    (20) exp -> exp . at type dot identifier lparen param_list rparen
    (21) exp -> exp . at type dot identifier lparen rparen
    (42) exp -> exp . plus exp
    (43) exp -> exp . minus exp
    (44) exp -> exp . times exp
    (45) exp -> exp . divide exp
    (47) exp -> exp . lt exp
    (48) exp -> exp . le exp
    (49) exp -> exp . equals exp

    of              reduce using rule 49 (exp -> exp equals exp .)
    lt              reduce using rule 49 (exp -> exp equals exp .)
    le              reduce using rule 49 (exp -> exp equals exp .)
    equals          reduce using rule 49 (exp -> exp equals exp .)
    semi            reduce using rule 49 (exp -> exp equals exp .)
    then            reduce using rule 49 (exp -> exp equals exp .)
    rparen          reduce using rule 49 (exp -> exp equals exp .)
    loop            reduce using rule 49 (exp -> exp equals exp .)
    comma           reduce using rule 49 (exp -> exp equals exp .)
    rbrace          reduce using rule 49 (exp -> exp equals exp .)
    else            reduce using rule 49 (exp -> exp equals exp .)
    pool            reduce using rule 49 (exp -> exp equals exp .)
    fi              reduce using rule 49 (exp -> exp equals exp .)
    in              reduce using rule 49 (exp -> exp equals exp .)
    dot             shift and go to state 74
    at              shift and go to state 71
    plus            shift and go to state 72
    minus           shift and go to state 73
    times           shift and go to state 69
    divide          shift and go to state 75

  ! dot             [ reduce using rule 49 (exp -> exp equals exp .) ]
  ! at              [ reduce using rule 49 (exp -> exp equals exp .) ]
  ! plus            [ reduce using rule 49 (exp -> exp equals exp .) ]
  ! minus           [ reduce using rule 49 (exp -> exp equals exp .) ]
  ! times           [ reduce using rule 49 (exp -> exp equals exp .) ]
  ! divide          [ reduce using rule 49 (exp -> exp equals exp .) ]
  ! lt              [ shift and go to state 70 ]
  ! le              [ shift and go to state 67 ]
  ! equals          [ shift and go to state 68 ]


state 91

    (44) exp -> exp times exp .
    (18) exp -> exp . dot identifier lparen param_list rparen
    (19) exp -> exp . dot identifier lparen rparen
    (20) exp -> exp . at type dot identifier lparen param_list rparen
    (21) exp -> exp . at type dot identifier lparen rparen
    (42) exp -> exp . plus exp
    (43) exp -> exp . minus exp
    (44) exp -> exp . times exp
    (45) exp -> exp . divide exp
    (47) exp -> exp . lt exp
    (48) exp -> exp . le exp
    (49) exp -> exp . equals exp

    of              reduce using rule 44 (exp -> exp times exp .)
    plus            reduce using rule 44 (exp -> exp times exp .)
    minus           reduce using rule 44 (exp -> exp times exp .)
    times           reduce using rule 44 (exp -> exp times exp .)
    divide          reduce using rule 44 (exp -> exp times exp .)
    lt              reduce using rule 44 (exp -> exp times exp .)
    le              reduce using rule 44 (exp -> exp times exp .)
    equals          reduce using rule 44 (exp -> exp times exp .)
    semi            reduce using rule 44 (exp -> exp times exp .)
    then            reduce using rule 44 (exp -> exp times exp .)
    rparen          reduce using rule 44 (exp -> exp times exp .)
    loop            reduce using rule 44 (exp -> exp times exp .)
    comma           reduce using rule 44 (exp -> exp times exp .)
    rbrace          reduce using rule 44 (exp -> exp times exp .)
    else            reduce using rule 44 (exp -> exp times exp .)
    pool            reduce using rule 44 (exp -> exp times exp .)
    fi              reduce using rule 44 (exp -> exp times exp .)
    in              reduce using rule 44 (exp -> exp times exp .)
    dot             shift and go to state 74
    at              shift and go to state 71

  ! dot             [ reduce using rule 44 (exp -> exp times exp .) ]
  ! at              [ reduce using rule 44 (exp -> exp times exp .) ]
  ! plus            [ shift and go to state 72 ]
  ! minus           [ shift and go to state 73 ]
  ! times           [ shift and go to state 69 ]
  ! divide          [ shift and go to state 75 ]
  ! lt              [ shift and go to state 70 ]
  ! le              [ shift and go to state 67 ]
  ! equals          [ shift and go to state 68 ]


state 92

    (47) exp -> exp lt exp .
    (18) exp -> exp . dot identifier lparen param_list rparen
    (19) exp -> exp . dot identifier lparen rparen
    (20) exp -> exp . at type dot identifier lparen param_list rparen
    (21) exp -> exp . at type dot identifier lparen rparen
    (42) exp -> exp . plus exp
    (43) exp -> exp . minus exp
    (44) exp -> exp . times exp
    (45) exp -> exp . divide exp
    (47) exp -> exp . lt exp
    (48) exp -> exp . le exp
    (49) exp -> exp . equals exp

    of              reduce using rule 47 (exp -> exp lt exp .)
    lt              reduce using rule 47 (exp -> exp lt exp .)
    le              reduce using rule 47 (exp -> exp lt exp .)
    equals          reduce using rule 47 (exp -> exp lt exp .)
    semi            reduce using rule 47 (exp -> exp lt exp .)
    then            reduce using rule 47 (exp -> exp lt exp .)
    rparen          reduce using rule 47 (exp -> exp lt exp .)
    loop            reduce using rule 47 (exp -> exp lt exp .)
    comma           reduce using rule 47 (exp -> exp lt exp .)
    rbrace          reduce using rule 47 (exp -> exp lt exp .)
    else            reduce using rule 47 (exp -> exp lt exp .)
    pool            reduce using rule 47 (exp -> exp lt exp .)
    fi              reduce using rule 47 (exp -> exp lt exp .)
    in              reduce using rule 47 (exp -> exp lt exp .)
    dot             shift and go to state 74
    at              shift and go to state 71
    plus            shift and go to state 72
    minus           shift and go to state 73
    times           shift and go to state 69
    divide          shift and go to state 75

  ! dot             [ reduce using rule 47 (exp -> exp lt exp .) ]
  ! at              [ reduce using rule 47 (exp -> exp lt exp .) ]
  ! plus            [ reduce using rule 47 (exp -> exp lt exp .) ]
  ! minus           [ reduce using rule 47 (exp -> exp lt exp .) ]
  ! times           [ reduce using rule 47 (exp -> exp lt exp .) ]
  ! divide          [ reduce using rule 47 (exp -> exp lt exp .) ]
  ! lt              [ shift and go to state 70 ]
  ! le              [ shift and go to state 67 ]
  ! equals          [ shift and go to state 68 ]


state 93

    (20) exp -> exp at type . dot identifier lparen param_list rparen
    (21) exp -> exp at type . dot identifier lparen rparen

    dot             shift and go to state 113


state 94

    (42) exp -> exp plus exp .
    (18) exp -> exp . dot identifier lparen param_list rparen
    (19) exp -> exp . dot identifier lparen rparen
    (20) exp -> exp . at type dot identifier lparen param_list rparen
    (21) exp -> exp . at type dot identifier lparen rparen
    (42) exp -> exp . plus exp
    (43) exp -> exp . minus exp
    (44) exp -> exp . times exp
    (45) exp -> exp . divide exp
    (47) exp -> exp . lt exp
    (48) exp -> exp . le exp
    (49) exp -> exp . equals exp

    of              reduce using rule 42 (exp -> exp plus exp .)
    plus            reduce using rule 42 (exp -> exp plus exp .)
    minus           reduce using rule 42 (exp -> exp plus exp .)
    lt              reduce using rule 42 (exp -> exp plus exp .)
    le              reduce using rule 42 (exp -> exp plus exp .)
    equals          reduce using rule 42 (exp -> exp plus exp .)
    semi            reduce using rule 42 (exp -> exp plus exp .)
    then            reduce using rule 42 (exp -> exp plus exp .)
    rparen          reduce using rule 42 (exp -> exp plus exp .)
    loop            reduce using rule 42 (exp -> exp plus exp .)
    comma           reduce using rule 42 (exp -> exp plus exp .)
    rbrace          reduce using rule 42 (exp -> exp plus exp .)
    else            reduce using rule 42 (exp -> exp plus exp .)
    pool            reduce using rule 42 (exp -> exp plus exp .)
    fi              reduce using rule 42 (exp -> exp plus exp .)
    in              reduce using rule 42 (exp -> exp plus exp .)
    dot             shift and go to state 74
    at              shift and go to state 71
    times           shift and go to state 69
    divide          shift and go to state 75

  ! dot             [ reduce using rule 42 (exp -> exp plus exp .) ]
  ! at              [ reduce using rule 42 (exp -> exp plus exp .) ]
  ! times           [ reduce using rule 42 (exp -> exp plus exp .) ]
  ! divide          [ reduce using rule 42 (exp -> exp plus exp .) ]
  ! plus            [ shift and go to state 72 ]
  ! minus           [ shift and go to state 73 ]
  ! lt              [ shift and go to state 70 ]
  ! le              [ shift and go to state 67 ]
  ! equals          [ shift and go to state 68 ]


state 95

    (43) exp -> exp minus exp .
    (18) exp -> exp . dot identifier lparen param_list rparen
    (19) exp -> exp . dot identifier lparen rparen
    (20) exp -> exp . at type dot identifier lparen param_list rparen
    (21) exp -> exp . at type dot identifier lparen rparen
    (42) exp -> exp . plus exp
    (43) exp -> exp . minus exp
    (44) exp -> exp . times exp
    (45) exp -> exp . divide exp
    (47) exp -> exp . lt exp
    (48) exp -> exp . le exp
    (49) exp -> exp . equals exp

    of              reduce using rule 43 (exp -> exp minus exp .)
    plus            reduce using rule 43 (exp -> exp minus exp .)
    minus           reduce using rule 43 (exp -> exp minus exp .)
    lt              reduce using rule 43 (exp -> exp minus exp .)
    le              reduce using rule 43 (exp -> exp minus exp .)
    equals          reduce using rule 43 (exp -> exp minus exp .)
    semi            reduce using rule 43 (exp -> exp minus exp .)
    then            reduce using rule 43 (exp -> exp minus exp .)
    rparen          reduce using rule 43 (exp -> exp minus exp .)
    loop            reduce using rule 43 (exp -> exp minus exp .)
    comma           reduce using rule 43 (exp -> exp minus exp .)
    rbrace          reduce using rule 43 (exp -> exp minus exp .)
    else            reduce using rule 43 (exp -> exp minus exp .)
    pool            reduce using rule 43 (exp -> exp minus exp .)
    fi              reduce using rule 43 (exp -> exp minus exp .)
    in              reduce using rule 43 (exp -> exp minus exp .)
    dot             shift and go to state 74
    at              shift and go to state 71
    times           shift and go to state 69
    divide          shift and go to state 75

  ! dot             [ reduce using rule 43 (exp -> exp minus exp .) ]
  ! at              [ reduce using rule 43 (exp -> exp minus exp .) ]
  ! times           [ reduce using rule 43 (exp -> exp minus exp .) ]
  ! divide          [ reduce using rule 43 (exp -> exp minus exp .) ]
  ! plus            [ shift and go to state 72 ]
  ! minus           [ shift and go to state 73 ]
  ! lt              [ shift and go to state 70 ]
  ! le              [ shift and go to state 67 ]
  ! equals          [ shift and go to state 68 ]


state 96

    (18) exp -> exp dot identifier . lparen param_list rparen
    (19) exp -> exp dot identifier . lparen rparen

    lparen          shift and go to state 114


state 97

    (45) exp -> exp divide exp .
    (18) exp -> exp . dot identifier lparen param_list rparen
    (19) exp -> exp . dot identifier lparen rparen
    (20) exp -> exp . at type dot identifier lparen param_list rparen
    (21) exp -> exp . at type dot identifier lparen rparen
    (42) exp -> exp . plus exp
    (43) exp -> exp . minus exp
    (44) exp -> exp . times exp
    (45) exp -> exp . divide exp
    (47) exp -> exp . lt exp
    (48) exp -> exp . le exp
    (49) exp -> exp . equals exp

    of              reduce using rule 45 (exp -> exp divide exp .)
    plus            reduce using rule 45 (exp -> exp divide exp .)
    minus           reduce using rule 45 (exp -> exp divide exp .)
    times           reduce using rule 45 (exp -> exp divide exp .)
    divide          reduce using rule 45 (exp -> exp divide exp .)
    lt              reduce using rule 45 (exp -> exp divide exp .)
    le              reduce using rule 45 (exp -> exp divide exp .)
    equals          reduce using rule 45 (exp -> exp divide exp .)
    semi            reduce using rule 45 (exp -> exp divide exp .)
    then            reduce using rule 45 (exp -> exp divide exp .)
    rparen          reduce using rule 45 (exp -> exp divide exp .)
    loop            reduce using rule 45 (exp -> exp divide exp .)
    comma           reduce using rule 45 (exp -> exp divide exp .)
    rbrace          reduce using rule 45 (exp -> exp divide exp .)
    else            reduce using rule 45 (exp -> exp divide exp .)
    pool            reduce using rule 45 (exp -> exp divide exp .)
    fi              reduce using rule 45 (exp -> exp divide exp .)
    in              reduce using rule 45 (exp -> exp divide exp .)
    dot             shift and go to state 74
    at              shift and go to state 71

  ! dot             [ reduce using rule 45 (exp -> exp divide exp .) ]
  ! at              [ reduce using rule 45 (exp -> exp divide exp .) ]
  ! plus            [ shift and go to state 72 ]
  ! minus           [ shift and go to state 73 ]
  ! times           [ shift and go to state 69 ]
  ! divide          [ shift and go to state 75 ]
  ! lt              [ shift and go to state 70 ]
  ! le              [ shift and go to state 67 ]
  ! equals          [ shift and go to state 68 ]


state 98

    (17) exp -> identifier larrow exp .
    (18) exp -> exp . dot identifier lparen param_list rparen
    (19) exp -> exp . dot identifier lparen rparen
    (20) exp -> exp . at type dot identifier lparen param_list rparen
    (21) exp -> exp . at type dot identifier lparen rparen
    (42) exp -> exp . plus exp
    (43) exp -> exp . minus exp
    (44) exp -> exp . times exp
    (45) exp -> exp . divide exp
    (47) exp -> exp . lt exp
    (48) exp -> exp . le exp
    (49) exp -> exp . equals exp

    of              reduce using rule 17 (exp -> identifier larrow exp .)
    semi            reduce using rule 17 (exp -> identifier larrow exp .)
    then            reduce using rule 17 (exp -> identifier larrow exp .)
    rparen          reduce using rule 17 (exp -> identifier larrow exp .)
    loop            reduce using rule 17 (exp -> identifier larrow exp .)
    comma           reduce using rule 17 (exp -> identifier larrow exp .)
    rbrace          reduce using rule 17 (exp -> identifier larrow exp .)
    else            reduce using rule 17 (exp -> identifier larrow exp .)
    pool            reduce using rule 17 (exp -> identifier larrow exp .)
    fi              reduce using rule 17 (exp -> identifier larrow exp .)
    in              reduce using rule 17 (exp -> identifier larrow exp .)
    dot             shift and go to state 74
    at              shift and go to state 71
    plus            shift and go to state 72
    minus           shift and go to state 73
    times           shift and go to state 69
    divide          shift and go to state 75
    lt              shift and go to state 70
    le              shift and go to state 67
    equals          shift and go to state 68

  ! dot             [ reduce using rule 17 (exp -> identifier larrow exp .) ]
  ! at              [ reduce using rule 17 (exp -> identifier larrow exp .) ]
  ! plus            [ reduce using rule 17 (exp -> identifier larrow exp .) ]
  ! minus           [ reduce using rule 17 (exp -> identifier larrow exp .) ]
  ! times           [ reduce using rule 17 (exp -> identifier larrow exp .) ]
  ! divide          [ reduce using rule 17 (exp -> identifier larrow exp .) ]
  ! lt              [ reduce using rule 17 (exp -> identifier larrow exp .) ]
  ! le              [ reduce using rule 17 (exp -> identifier larrow exp .) ]
  ! equals          [ reduce using rule 17 (exp -> identifier larrow exp .) ]


state 99

    (22) exp -> identifier lparen param_list . rparen

    rparen          shift and go to state 115


state 100

    (23) exp -> identifier lparen rparen .

    of              reduce using rule 23 (exp -> identifier lparen rparen .)
    dot             reduce using rule 23 (exp -> identifier lparen rparen .)
    at              reduce using rule 23 (exp -> identifier lparen rparen .)
    plus            reduce using rule 23 (exp -> identifier lparen rparen .)
    minus           reduce using rule 23 (exp -> identifier lparen rparen .)
    times           reduce using rule 23 (exp -> identifier lparen rparen .)
    divide          reduce using rule 23 (exp -> identifier lparen rparen .)
    lt              reduce using rule 23 (exp -> identifier lparen rparen .)
    le              reduce using rule 23 (exp -> identifier lparen rparen .)
    equals          reduce using rule 23 (exp -> identifier lparen rparen .)
    semi            reduce using rule 23 (exp -> identifier lparen rparen .)
    then            reduce using rule 23 (exp -> identifier lparen rparen .)
    rparen          reduce using rule 23 (exp -> identifier lparen rparen .)
    loop            reduce using rule 23 (exp -> identifier lparen rparen .)
    comma           reduce using rule 23 (exp -> identifier lparen rparen .)
    rbrace          reduce using rule 23 (exp -> identifier lparen rparen .)
    else            reduce using rule 23 (exp -> identifier lparen rparen .)
    pool            reduce using rule 23 (exp -> identifier lparen rparen .)
    fi              reduce using rule 23 (exp -> identifier lparen rparen .)
    in              reduce using rule 23 (exp -> identifier lparen rparen .)


state 101

    (24) param_list -> exp . comma param_list
    (25) param_list -> exp .
    (18) exp -> exp . dot identifier lparen param_list rparen
    (19) exp -> exp . dot identifier lparen rparen
    (20) exp -> exp . at type dot identifier lparen param_list rparen
    (21) exp -> exp . at type dot identifier lparen rparen
    (42) exp -> exp . plus exp
    (43) exp -> exp . minus exp
    (44) exp -> exp . times exp
    (45) exp -> exp . divide exp
    (47) exp -> exp . lt exp
    (48) exp -> exp . le exp
    (49) exp -> exp . equals exp

    comma           shift and go to state 116
    rparen          reduce using rule 25 (param_list -> exp .)
    dot             shift and go to state 74
    at              shift and go to state 71
    plus            shift and go to state 72
    minus           shift and go to state 73
    times           shift and go to state 69
    divide          shift and go to state 75
    lt              shift and go to state 70
    le              shift and go to state 67
    equals          shift and go to state 68


state 102

    (13) feature -> identifier lparen rparen colon type lbrace exp . rbrace
    (18) exp -> exp . dot identifier lparen param_list rparen
    (19) exp -> exp . dot identifier lparen rparen
    (20) exp -> exp . at type dot identifier lparen param_list rparen
    (21) exp -> exp . at type dot identifier lparen rparen
    (42) exp -> exp . plus exp
    (43) exp -> exp . minus exp
    (44) exp -> exp . times exp
    (45) exp -> exp . divide exp
    (47) exp -> exp . lt exp
    (48) exp -> exp . le exp
    (49) exp -> exp . equals exp

    rbrace          shift and go to state 117
    dot             shift and go to state 74
    at              shift and go to state 71
    plus            shift and go to state 72
    minus           shift and go to state 73
    times           shift and go to state 69
    divide          shift and go to state 75
    lt              shift and go to state 70
    le              shift and go to state 67
    equals          shift and go to state 68


state 103

    (12) feature -> identifier lparen formal_list rparen colon type lbrace . exp rbrace
    (17) exp -> . identifier larrow exp
    (18) exp -> . exp dot identifier lparen param_list rparen
    (19) exp -> . exp dot identifier lparen rparen
    (20) exp -> . exp at type dot identifier lparen param_list rparen
    (21) exp -> . exp at type dot identifier lparen rparen
    (22) exp -> . identifier lparen param_list rparen
    (23) exp -> . identifier lparen rparen
    (26) exp -> . if exp then exp else exp fi
    (27) exp -> . while exp loop exp pool
    (28) exp -> . lbrace exp_list rbrace
    (31) exp -> . let let_binding_list in exp
    (36) exp -> . case exp of case_elements esac
    (40) exp -> . new type
    (41) exp -> . isvoid exp
    (42) exp -> . exp plus exp
    (43) exp -> . exp minus exp
    (44) exp -> . exp times exp
    (45) exp -> . exp divide exp
    (46) exp -> . tilde exp
    (47) exp -> . exp lt exp
    (48) exp -> . exp le exp
    (49) exp -> . exp equals exp
    (50) exp -> . not exp
    (51) exp -> . lparen exp rparen
    (52) exp -> . identifier
    (53) exp -> . integer
    (54) exp -> . string
    (55) exp -> . true
    (56) exp -> . false

    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 47
    lbrace          shift and go to state 46
    let             shift and go to state 41
    case            shift and go to state 45
    new             shift and go to state 39
    isvoid          shift and go to state 38
    tilde           shift and go to state 35
    not             shift and go to state 43
    lparen          shift and go to state 42
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 44
    false           shift and go to state 34

    exp                            shift and go to state 118

state 104

    (26) exp -> if exp then exp . else exp fi
    (18) exp -> exp . dot identifier lparen param_list rparen
    (19) exp -> exp . dot identifier lparen rparen
    (20) exp -> exp . at type dot identifier lparen param_list rparen
    (21) exp -> exp . at type dot identifier lparen rparen
    (42) exp -> exp . plus exp
    (43) exp -> exp . minus exp
    (44) exp -> exp . times exp
    (45) exp -> exp . divide exp
    (47) exp -> exp . lt exp
    (48) exp -> exp . le exp
    (49) exp -> exp . equals exp

    else            shift and go to state 119
    dot             shift and go to state 74
    at              shift and go to state 71
    plus            shift and go to state 72
    minus           shift and go to state 73
    times           shift and go to state 69
    divide          shift and go to state 75
    lt              shift and go to state 70
    le              shift and go to state 67
    equals          shift and go to state 68


state 105

    (31) exp -> let let_binding_list in exp .
    (18) exp -> exp . dot identifier lparen param_list rparen
    (19) exp -> exp . dot identifier lparen rparen
    (20) exp -> exp . at type dot identifier lparen param_list rparen
    (21) exp -> exp . at type dot identifier lparen rparen
    (42) exp -> exp . plus exp
    (43) exp -> exp . minus exp
    (44) exp -> exp . times exp
    (45) exp -> exp . divide exp
    (47) exp -> exp . lt exp
    (48) exp -> exp . le exp
    (49) exp -> exp . equals exp

    of              reduce using rule 31 (exp -> let let_binding_list in exp .)
    semi            reduce using rule 31 (exp -> let let_binding_list in exp .)
    then            reduce using rule 31 (exp -> let let_binding_list in exp .)
    rparen          reduce using rule 31 (exp -> let let_binding_list in exp .)
    loop            reduce using rule 31 (exp -> let let_binding_list in exp .)
    comma           reduce using rule 31 (exp -> let let_binding_list in exp .)
    rbrace          reduce using rule 31 (exp -> let let_binding_list in exp .)
    else            reduce using rule 31 (exp -> let let_binding_list in exp .)
    pool            reduce using rule 31 (exp -> let let_binding_list in exp .)
    fi              reduce using rule 31 (exp -> let let_binding_list in exp .)
    in              reduce using rule 31 (exp -> let let_binding_list in exp .)
    dot             shift and go to state 74
    at              shift and go to state 71
    plus            shift and go to state 72
    minus           shift and go to state 73
    times           shift and go to state 69
    divide          shift and go to state 75
    lt              shift and go to state 70
    le              shift and go to state 67
    equals          shift and go to state 68

  ! dot             [ reduce using rule 31 (exp -> let let_binding_list in exp .) ]
  ! at              [ reduce using rule 31 (exp -> let let_binding_list in exp .) ]
  ! plus            [ reduce using rule 31 (exp -> let let_binding_list in exp .) ]
  ! minus           [ reduce using rule 31 (exp -> let let_binding_list in exp .) ]
  ! times           [ reduce using rule 31 (exp -> let let_binding_list in exp .) ]
  ! divide          [ reduce using rule 31 (exp -> let let_binding_list in exp .) ]
  ! lt              [ reduce using rule 31 (exp -> let let_binding_list in exp .) ]
  ! le              [ reduce using rule 31 (exp -> let let_binding_list in exp .) ]
  ! equals          [ reduce using rule 31 (exp -> let let_binding_list in exp .) ]


state 106

    (32) let_binding_list -> let_binding comma let_binding_list .

    in              reduce using rule 32 (let_binding_list -> let_binding comma let_binding_list .)


state 107

    (34) let_binding -> identifier colon type .
    (35) let_binding -> identifier colon type . larrow exp

    comma           reduce using rule 34 (let_binding -> identifier colon type .)
    in              reduce using rule 34 (let_binding -> identifier colon type .)
    larrow          shift and go to state 120


state 108

    (37) case_elements -> case_element . semi case_elements
    (38) case_elements -> case_element . semi

    semi            shift and go to state 121


state 109

    (39) case_element -> identifier . colon type rarrow exp

    colon           shift and go to state 122


state 110

    (36) exp -> case exp of case_elements . esac

    esac            shift and go to state 123


state 111

    (29) exp_list -> exp semi exp_list .

    rbrace          reduce using rule 29 (exp_list -> exp semi exp_list .)


state 112

    (27) exp -> while exp loop exp . pool
    (18) exp -> exp . dot identifier lparen param_list rparen
    (19) exp -> exp . dot identifier lparen rparen
    (20) exp -> exp . at type dot identifier lparen param_list rparen
    (21) exp -> exp . at type dot identifier lparen rparen
    (42) exp -> exp . plus exp
    (43) exp -> exp . minus exp
    (44) exp -> exp . times exp
    (45) exp -> exp . divide exp
    (47) exp -> exp . lt exp
    (48) exp -> exp . le exp
    (49) exp -> exp . equals exp

    pool            shift and go to state 124
    dot             shift and go to state 74
    at              shift and go to state 71
    plus            shift and go to state 72
    minus           shift and go to state 73
    times           shift and go to state 69
    divide          shift and go to state 75
    lt              shift and go to state 70
    le              shift and go to state 67
    equals          shift and go to state 68


state 113

    (20) exp -> exp at type dot . identifier lparen param_list rparen
    (21) exp -> exp at type dot . identifier lparen rparen

    identifier      shift and go to state 125


state 114

    (18) exp -> exp dot identifier lparen . param_list rparen
    (19) exp -> exp dot identifier lparen . rparen
    (24) param_list -> . exp comma param_list
    (25) param_list -> . exp
    (17) exp -> . identifier larrow exp
    (18) exp -> . exp dot identifier lparen param_list rparen
    (19) exp -> . exp dot identifier lparen rparen
    (20) exp -> . exp at type dot identifier lparen param_list rparen
    (21) exp -> . exp at type dot identifier lparen rparen
    (22) exp -> . identifier lparen param_list rparen
    (23) exp -> . identifier lparen rparen
    (26) exp -> . if exp then exp else exp fi
    (27) exp -> . while exp loop exp pool
    (28) exp -> . lbrace exp_list rbrace
    (31) exp -> . let let_binding_list in exp
    (36) exp -> . case exp of case_elements esac
    (40) exp -> . new type
    (41) exp -> . isvoid exp
    (42) exp -> . exp plus exp
    (43) exp -> . exp minus exp
    (44) exp -> . exp times exp
    (45) exp -> . exp divide exp
    (46) exp -> . tilde exp
    (47) exp -> . exp lt exp
    (48) exp -> . exp le exp
    (49) exp -> . exp equals exp
    (50) exp -> . not exp
    (51) exp -> . lparen exp rparen
    (52) exp -> . identifier
    (53) exp -> . integer
    (54) exp -> . string
    (55) exp -> . true
    (56) exp -> . false

    rparen          shift and go to state 127
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 47
    lbrace          shift and go to state 46
    let             shift and go to state 41
    case            shift and go to state 45
    new             shift and go to state 39
    isvoid          shift and go to state 38
    tilde           shift and go to state 35
    not             shift and go to state 43
    lparen          shift and go to state 42
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 44
    false           shift and go to state 34

    param_list                     shift and go to state 126
    exp                            shift and go to state 101

state 115

    (22) exp -> identifier lparen param_list rparen .

    of              reduce using rule 22 (exp -> identifier lparen param_list rparen .)
    dot             reduce using rule 22 (exp -> identifier lparen param_list rparen .)
    at              reduce using rule 22 (exp -> identifier lparen param_list rparen .)
    plus            reduce using rule 22 (exp -> identifier lparen param_list rparen .)
    minus           reduce using rule 22 (exp -> identifier lparen param_list rparen .)
    times           reduce using rule 22 (exp -> identifier lparen param_list rparen .)
    divide          reduce using rule 22 (exp -> identifier lparen param_list rparen .)
    lt              reduce using rule 22 (exp -> identifier lparen param_list rparen .)
    le              reduce using rule 22 (exp -> identifier lparen param_list rparen .)
    equals          reduce using rule 22 (exp -> identifier lparen param_list rparen .)
    semi            reduce using rule 22 (exp -> identifier lparen param_list rparen .)
    then            reduce using rule 22 (exp -> identifier lparen param_list rparen .)
    rparen          reduce using rule 22 (exp -> identifier lparen param_list rparen .)
    loop            reduce using rule 22 (exp -> identifier lparen param_list rparen .)
    comma           reduce using rule 22 (exp -> identifier lparen param_list rparen .)
    rbrace          reduce using rule 22 (exp -> identifier lparen param_list rparen .)
    else            reduce using rule 22 (exp -> identifier lparen param_list rparen .)
    pool            reduce using rule 22 (exp -> identifier lparen param_list rparen .)
    fi              reduce using rule 22 (exp -> identifier lparen param_list rparen .)
    in              reduce using rule 22 (exp -> identifier lparen param_list rparen .)


state 116

    (24) param_list -> exp comma . param_list
    (24) param_list -> . exp comma param_list
    (25) param_list -> . exp
    (17) exp -> . identifier larrow exp
    (18) exp -> . exp dot identifier lparen param_list rparen
    (19) exp -> . exp dot identifier lparen rparen
    (20) exp -> . exp at type dot identifier lparen param_list rparen
    (21) exp -> . exp at type dot identifier lparen rparen
    (22) exp -> . identifier lparen param_list rparen
    (23) exp -> . identifier lparen rparen
    (26) exp -> . if exp then exp else exp fi
    (27) exp -> . while exp loop exp pool
    (28) exp -> . lbrace exp_list rbrace
    (31) exp -> . let let_binding_list in exp
    (36) exp -> . case exp of case_elements esac
    (40) exp -> . new type
    (41) exp -> . isvoid exp
    (42) exp -> . exp plus exp
    (43) exp -> . exp minus exp
    (44) exp -> . exp times exp
    (45) exp -> . exp divide exp
    (46) exp -> . tilde exp
    (47) exp -> . exp lt exp
    (48) exp -> . exp le exp
    (49) exp -> . exp equals exp
    (50) exp -> . not exp
    (51) exp -> . lparen exp rparen
    (52) exp -> . identifier
    (53) exp -> . integer
    (54) exp -> . string
    (55) exp -> . true
    (56) exp -> . false

    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 47
    lbrace          shift and go to state 46
    let             shift and go to state 41
    case            shift and go to state 45
    new             shift and go to state 39
    isvoid          shift and go to state 38
    tilde           shift and go to state 35
    not             shift and go to state 43
    lparen          shift and go to state 42
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 44
    false           shift and go to state 34

    param_list                     shift and go to state 128
    exp                            shift and go to state 101

state 117

    (13) feature -> identifier lparen rparen colon type lbrace exp rbrace .

    semi            reduce using rule 13 (feature -> identifier lparen rparen colon type lbrace exp rbrace .)


state 118

    (12) feature -> identifier lparen formal_list rparen colon type lbrace exp . rbrace
    (18) exp -> exp . dot identifier lparen param_list rparen
    (19) exp -> exp . dot identifier lparen rparen
    (20) exp -> exp . at type dot identifier lparen param_list rparen
    (21) exp -> exp . at type dot identifier lparen rparen
    (42) exp -> exp . plus exp
    (43) exp -> exp . minus exp
    (44) exp -> exp . times exp
    (45) exp -> exp . divide exp
    (47) exp -> exp . lt exp
    (48) exp -> exp . le exp
    (49) exp -> exp . equals exp

    rbrace          shift and go to state 129
    dot             shift and go to state 74
    at              shift and go to state 71
    plus            shift and go to state 72
    minus           shift and go to state 73
    times           shift and go to state 69
    divide          shift and go to state 75
    lt              shift and go to state 70
    le              shift and go to state 67
    equals          shift and go to state 68


state 119

    (26) exp -> if exp then exp else . exp fi
    (17) exp -> . identifier larrow exp
    (18) exp -> . exp dot identifier lparen param_list rparen
    (19) exp -> . exp dot identifier lparen rparen
    (20) exp -> . exp at type dot identifier lparen param_list rparen
    (21) exp -> . exp at type dot identifier lparen rparen
    (22) exp -> . identifier lparen param_list rparen
    (23) exp -> . identifier lparen rparen
    (26) exp -> . if exp then exp else exp fi
    (27) exp -> . while exp loop exp pool
    (28) exp -> . lbrace exp_list rbrace
    (31) exp -> . let let_binding_list in exp
    (36) exp -> . case exp of case_elements esac
    (40) exp -> . new type
    (41) exp -> . isvoid exp
    (42) exp -> . exp plus exp
    (43) exp -> . exp minus exp
    (44) exp -> . exp times exp
    (45) exp -> . exp divide exp
    (46) exp -> . tilde exp
    (47) exp -> . exp lt exp
    (48) exp -> . exp le exp
    (49) exp -> . exp equals exp
    (50) exp -> . not exp
    (51) exp -> . lparen exp rparen
    (52) exp -> . identifier
    (53) exp -> . integer
    (54) exp -> . string
    (55) exp -> . true
    (56) exp -> . false

    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 47
    lbrace          shift and go to state 46
    let             shift and go to state 41
    case            shift and go to state 45
    new             shift and go to state 39
    isvoid          shift and go to state 38
    tilde           shift and go to state 35
    not             shift and go to state 43
    lparen          shift and go to state 42
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 44
    false           shift and go to state 34

    exp                            shift and go to state 130

state 120

    (35) let_binding -> identifier colon type larrow . exp
    (17) exp -> . identifier larrow exp
    (18) exp -> . exp dot identifier lparen param_list rparen
    (19) exp -> . exp dot identifier lparen rparen
    (20) exp -> . exp at type dot identifier lparen param_list rparen
    (21) exp -> . exp at type dot identifier lparen rparen
    (22) exp -> . identifier lparen param_list rparen
    (23) exp -> . identifier lparen rparen
    (26) exp -> . if exp then exp else exp fi
    (27) exp -> . while exp loop exp pool
    (28) exp -> . lbrace exp_list rbrace
    (31) exp -> . let let_binding_list in exp
    (36) exp -> . case exp of case_elements esac
    (40) exp -> . new type
    (41) exp -> . isvoid exp
    (42) exp -> . exp plus exp
    (43) exp -> . exp minus exp
    (44) exp -> . exp times exp
    (45) exp -> . exp divide exp
    (46) exp -> . tilde exp
    (47) exp -> . exp lt exp
    (48) exp -> . exp le exp
    (49) exp -> . exp equals exp
    (50) exp -> . not exp
    (51) exp -> . lparen exp rparen
    (52) exp -> . identifier
    (53) exp -> . integer
    (54) exp -> . string
    (55) exp -> . true
    (56) exp -> . false

    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 47
    lbrace          shift and go to state 46
    let             shift and go to state 41
    case            shift and go to state 45
    new             shift and go to state 39
    isvoid          shift and go to state 38
    tilde           shift and go to state 35
    not             shift and go to state 43
    lparen          shift and go to state 42
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 44
    false           shift and go to state 34

    exp                            shift and go to state 131

state 121

    (37) case_elements -> case_element semi . case_elements
    (38) case_elements -> case_element semi .
    (37) case_elements -> . case_element semi case_elements
    (38) case_elements -> . case_element semi
    (39) case_element -> . identifier colon type rarrow exp

    esac            reduce using rule 38 (case_elements -> case_element semi .)
    identifier      shift and go to state 109

    case_element                   shift and go to state 108
    case_elements                  shift and go to state 132

state 122

    (39) case_element -> identifier colon . type rarrow exp

    type            shift and go to state 133


state 123

    (36) exp -> case exp of case_elements esac .

    of              reduce using rule 36 (exp -> case exp of case_elements esac .)
    dot             reduce using rule 36 (exp -> case exp of case_elements esac .)
    at              reduce using rule 36 (exp -> case exp of case_elements esac .)
    plus            reduce using rule 36 (exp -> case exp of case_elements esac .)
    minus           reduce using rule 36 (exp -> case exp of case_elements esac .)
    times           reduce using rule 36 (exp -> case exp of case_elements esac .)
    divide          reduce using rule 36 (exp -> case exp of case_elements esac .)
    lt              reduce using rule 36 (exp -> case exp of case_elements esac .)
    le              reduce using rule 36 (exp -> case exp of case_elements esac .)
    equals          reduce using rule 36 (exp -> case exp of case_elements esac .)
    semi            reduce using rule 36 (exp -> case exp of case_elements esac .)
    then            reduce using rule 36 (exp -> case exp of case_elements esac .)
    rparen          reduce using rule 36 (exp -> case exp of case_elements esac .)
    loop            reduce using rule 36 (exp -> case exp of case_elements esac .)
    comma           reduce using rule 36 (exp -> case exp of case_elements esac .)
    rbrace          reduce using rule 36 (exp -> case exp of case_elements esac .)
    else            reduce using rule 36 (exp -> case exp of case_elements esac .)
    pool            reduce using rule 36 (exp -> case exp of case_elements esac .)
    fi              reduce using rule 36 (exp -> case exp of case_elements esac .)
    in              reduce using rule 36 (exp -> case exp of case_elements esac .)


state 124

    (27) exp -> while exp loop exp pool .

    of              reduce using rule 27 (exp -> while exp loop exp pool .)
    dot             reduce using rule 27 (exp -> while exp loop exp pool .)
    at              reduce using rule 27 (exp -> while exp loop exp pool .)
    plus            reduce using rule 27 (exp -> while exp loop exp pool .)
    minus           reduce using rule 27 (exp -> while exp loop exp pool .)
    times           reduce using rule 27 (exp -> while exp loop exp pool .)
    divide          reduce using rule 27 (exp -> while exp loop exp pool .)
    lt              reduce using rule 27 (exp -> while exp loop exp pool .)
    le              reduce using rule 27 (exp -> while exp loop exp pool .)
    equals          reduce using rule 27 (exp -> while exp loop exp pool .)
    semi            reduce using rule 27 (exp -> while exp loop exp pool .)
    then            reduce using rule 27 (exp -> while exp loop exp pool .)
    rparen          reduce using rule 27 (exp -> while exp loop exp pool .)
    loop            reduce using rule 27 (exp -> while exp loop exp pool .)
    comma           reduce using rule 27 (exp -> while exp loop exp pool .)
    rbrace          reduce using rule 27 (exp -> while exp loop exp pool .)
    else            reduce using rule 27 (exp -> while exp loop exp pool .)
    pool            reduce using rule 27 (exp -> while exp loop exp pool .)
    fi              reduce using rule 27 (exp -> while exp loop exp pool .)
    in              reduce using rule 27 (exp -> while exp loop exp pool .)


state 125

    (20) exp -> exp at type dot identifier . lparen param_list rparen
    (21) exp -> exp at type dot identifier . lparen rparen

    lparen          shift and go to state 134


state 126

    (18) exp -> exp dot identifier lparen param_list . rparen

    rparen          shift and go to state 135


state 127

    (19) exp -> exp dot identifier lparen rparen .

    of              reduce using rule 19 (exp -> exp dot identifier lparen rparen .)
    dot             reduce using rule 19 (exp -> exp dot identifier lparen rparen .)
    at              reduce using rule 19 (exp -> exp dot identifier lparen rparen .)
    plus            reduce using rule 19 (exp -> exp dot identifier lparen rparen .)
    minus           reduce using rule 19 (exp -> exp dot identifier lparen rparen .)
    times           reduce using rule 19 (exp -> exp dot identifier lparen rparen .)
    divide          reduce using rule 19 (exp -> exp dot identifier lparen rparen .)
    lt              reduce using rule 19 (exp -> exp dot identifier lparen rparen .)
    le              reduce using rule 19 (exp -> exp dot identifier lparen rparen .)
    equals          reduce using rule 19 (exp -> exp dot identifier lparen rparen .)
    semi            reduce using rule 19 (exp -> exp dot identifier lparen rparen .)
    then            reduce using rule 19 (exp -> exp dot identifier lparen rparen .)
    rparen          reduce using rule 19 (exp -> exp dot identifier lparen rparen .)
    loop            reduce using rule 19 (exp -> exp dot identifier lparen rparen .)
    comma           reduce using rule 19 (exp -> exp dot identifier lparen rparen .)
    rbrace          reduce using rule 19 (exp -> exp dot identifier lparen rparen .)
    else            reduce using rule 19 (exp -> exp dot identifier lparen rparen .)
    pool            reduce using rule 19 (exp -> exp dot identifier lparen rparen .)
    fi              reduce using rule 19 (exp -> exp dot identifier lparen rparen .)
    in              reduce using rule 19 (exp -> exp dot identifier lparen rparen .)


state 128

    (24) param_list -> exp comma param_list .

    rparen          reduce using rule 24 (param_list -> exp comma param_list .)


state 129

    (12) feature -> identifier lparen formal_list rparen colon type lbrace exp rbrace .

    semi            reduce using rule 12 (feature -> identifier lparen formal_list rparen colon type lbrace exp rbrace .)


state 130

    (26) exp -> if exp then exp else exp . fi
    (18) exp -> exp . dot identifier lparen param_list rparen
    (19) exp -> exp . dot identifier lparen rparen
    (20) exp -> exp . at type dot identifier lparen param_list rparen
    (21) exp -> exp . at type dot identifier lparen rparen
    (42) exp -> exp . plus exp
    (43) exp -> exp . minus exp
    (44) exp -> exp . times exp
    (45) exp -> exp . divide exp
    (47) exp -> exp . lt exp
    (48) exp -> exp . le exp
    (49) exp -> exp . equals exp

    fi              shift and go to state 136
    dot             shift and go to state 74
    at              shift and go to state 71
    plus            shift and go to state 72
    minus           shift and go to state 73
    times           shift and go to state 69
    divide          shift and go to state 75
    lt              shift and go to state 70
    le              shift and go to state 67
    equals          shift and go to state 68


state 131

    (35) let_binding -> identifier colon type larrow exp .
    (18) exp -> exp . dot identifier lparen param_list rparen
    (19) exp -> exp . dot identifier lparen rparen
    (20) exp -> exp . at type dot identifier lparen param_list rparen
    (21) exp -> exp . at type dot identifier lparen rparen
    (42) exp -> exp . plus exp
    (43) exp -> exp . minus exp
    (44) exp -> exp . times exp
    (45) exp -> exp . divide exp
    (47) exp -> exp . lt exp
    (48) exp -> exp . le exp
    (49) exp -> exp . equals exp

    comma           reduce using rule 35 (let_binding -> identifier colon type larrow exp .)
    in              reduce using rule 35 (let_binding -> identifier colon type larrow exp .)
    dot             shift and go to state 74
    at              shift and go to state 71
    plus            shift and go to state 72
    minus           shift and go to state 73
    times           shift and go to state 69
    divide          shift and go to state 75
    lt              shift and go to state 70
    le              shift and go to state 67
    equals          shift and go to state 68


state 132

    (37) case_elements -> case_element semi case_elements .

    esac            reduce using rule 37 (case_elements -> case_element semi case_elements .)


state 133

    (39) case_element -> identifier colon type . rarrow exp

    rarrow          shift and go to state 137


state 134

    (20) exp -> exp at type dot identifier lparen . param_list rparen
    (21) exp -> exp at type dot identifier lparen . rparen
    (24) param_list -> . exp comma param_list
    (25) param_list -> . exp
    (17) exp -> . identifier larrow exp
    (18) exp -> . exp dot identifier lparen param_list rparen
    (19) exp -> . exp dot identifier lparen rparen
    (20) exp -> . exp at type dot identifier lparen param_list rparen
    (21) exp -> . exp at type dot identifier lparen rparen
    (22) exp -> . identifier lparen param_list rparen
    (23) exp -> . identifier lparen rparen
    (26) exp -> . if exp then exp else exp fi
    (27) exp -> . while exp loop exp pool
    (28) exp -> . lbrace exp_list rbrace
    (31) exp -> . let let_binding_list in exp
    (36) exp -> . case exp of case_elements esac
    (40) exp -> . new type
    (41) exp -> . isvoid exp
    (42) exp -> . exp plus exp
    (43) exp -> . exp minus exp
    (44) exp -> . exp times exp
    (45) exp -> . exp divide exp
    (46) exp -> . tilde exp
    (47) exp -> . exp lt exp
    (48) exp -> . exp le exp
    (49) exp -> . exp equals exp
    (50) exp -> . not exp
    (51) exp -> . lparen exp rparen
    (52) exp -> . identifier
    (53) exp -> . integer
    (54) exp -> . string
    (55) exp -> . true
    (56) exp -> . false

    rparen          shift and go to state 139
    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 47
    lbrace          shift and go to state 46
    let             shift and go to state 41
    case            shift and go to state 45
    new             shift and go to state 39
    isvoid          shift and go to state 38
    tilde           shift and go to state 35
    not             shift and go to state 43
    lparen          shift and go to state 42
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 44
    false           shift and go to state 34

    param_list                     shift and go to state 138
    exp                            shift and go to state 101

state 135

    (18) exp -> exp dot identifier lparen param_list rparen .

    of              reduce using rule 18 (exp -> exp dot identifier lparen param_list rparen .)
    dot             reduce using rule 18 (exp -> exp dot identifier lparen param_list rparen .)
    at              reduce using rule 18 (exp -> exp dot identifier lparen param_list rparen .)
    plus            reduce using rule 18 (exp -> exp dot identifier lparen param_list rparen .)
    minus           reduce using rule 18 (exp -> exp dot identifier lparen param_list rparen .)
    times           reduce using rule 18 (exp -> exp dot identifier lparen param_list rparen .)
    divide          reduce using rule 18 (exp -> exp dot identifier lparen param_list rparen .)
    lt              reduce using rule 18 (exp -> exp dot identifier lparen param_list rparen .)
    le              reduce using rule 18 (exp -> exp dot identifier lparen param_list rparen .)
    equals          reduce using rule 18 (exp -> exp dot identifier lparen param_list rparen .)
    semi            reduce using rule 18 (exp -> exp dot identifier lparen param_list rparen .)
    then            reduce using rule 18 (exp -> exp dot identifier lparen param_list rparen .)
    rparen          reduce using rule 18 (exp -> exp dot identifier lparen param_list rparen .)
    loop            reduce using rule 18 (exp -> exp dot identifier lparen param_list rparen .)
    comma           reduce using rule 18 (exp -> exp dot identifier lparen param_list rparen .)
    rbrace          reduce using rule 18 (exp -> exp dot identifier lparen param_list rparen .)
    else            reduce using rule 18 (exp -> exp dot identifier lparen param_list rparen .)
    pool            reduce using rule 18 (exp -> exp dot identifier lparen param_list rparen .)
    fi              reduce using rule 18 (exp -> exp dot identifier lparen param_list rparen .)
    in              reduce using rule 18 (exp -> exp dot identifier lparen param_list rparen .)


state 136

    (26) exp -> if exp then exp else exp fi .

    of              reduce using rule 26 (exp -> if exp then exp else exp fi .)
    dot             reduce using rule 26 (exp -> if exp then exp else exp fi .)
    at              reduce using rule 26 (exp -> if exp then exp else exp fi .)
    plus            reduce using rule 26 (exp -> if exp then exp else exp fi .)
    minus           reduce using rule 26 (exp -> if exp then exp else exp fi .)
    times           reduce using rule 26 (exp -> if exp then exp else exp fi .)
    divide          reduce using rule 26 (exp -> if exp then exp else exp fi .)
    lt              reduce using rule 26 (exp -> if exp then exp else exp fi .)
    le              reduce using rule 26 (exp -> if exp then exp else exp fi .)
    equals          reduce using rule 26 (exp -> if exp then exp else exp fi .)
    semi            reduce using rule 26 (exp -> if exp then exp else exp fi .)
    then            reduce using rule 26 (exp -> if exp then exp else exp fi .)
    rparen          reduce using rule 26 (exp -> if exp then exp else exp fi .)
    loop            reduce using rule 26 (exp -> if exp then exp else exp fi .)
    comma           reduce using rule 26 (exp -> if exp then exp else exp fi .)
    rbrace          reduce using rule 26 (exp -> if exp then exp else exp fi .)
    else            reduce using rule 26 (exp -> if exp then exp else exp fi .)
    pool            reduce using rule 26 (exp -> if exp then exp else exp fi .)
    fi              reduce using rule 26 (exp -> if exp then exp else exp fi .)
    in              reduce using rule 26 (exp -> if exp then exp else exp fi .)


state 137

    (39) case_element -> identifier colon type rarrow . exp
    (17) exp -> . identifier larrow exp
    (18) exp -> . exp dot identifier lparen param_list rparen
    (19) exp -> . exp dot identifier lparen rparen
    (20) exp -> . exp at type dot identifier lparen param_list rparen
    (21) exp -> . exp at type dot identifier lparen rparen
    (22) exp -> . identifier lparen param_list rparen
    (23) exp -> . identifier lparen rparen
    (26) exp -> . if exp then exp else exp fi
    (27) exp -> . while exp loop exp pool
    (28) exp -> . lbrace exp_list rbrace
    (31) exp -> . let let_binding_list in exp
    (36) exp -> . case exp of case_elements esac
    (40) exp -> . new type
    (41) exp -> . isvoid exp
    (42) exp -> . exp plus exp
    (43) exp -> . exp minus exp
    (44) exp -> . exp times exp
    (45) exp -> . exp divide exp
    (46) exp -> . tilde exp
    (47) exp -> . exp lt exp
    (48) exp -> . exp le exp
    (49) exp -> . exp equals exp
    (50) exp -> . not exp
    (51) exp -> . lparen exp rparen
    (52) exp -> . identifier
    (53) exp -> . integer
    (54) exp -> . string
    (55) exp -> . true
    (56) exp -> . false

    identifier      shift and go to state 49
    if              shift and go to state 36
    while           shift and go to state 47
    lbrace          shift and go to state 46
    let             shift and go to state 41
    case            shift and go to state 45
    new             shift and go to state 39
    isvoid          shift and go to state 38
    tilde           shift and go to state 35
    not             shift and go to state 43
    lparen          shift and go to state 42
    integer         shift and go to state 37
    string          shift and go to state 40
    true            shift and go to state 44
    false           shift and go to state 34

    exp                            shift and go to state 140

state 138

    (20) exp -> exp at type dot identifier lparen param_list . rparen

    rparen          shift and go to state 141


state 139

    (21) exp -> exp at type dot identifier lparen rparen .

    of              reduce using rule 21 (exp -> exp at type dot identifier lparen rparen .)
    dot             reduce using rule 21 (exp -> exp at type dot identifier lparen rparen .)
    at              reduce using rule 21 (exp -> exp at type dot identifier lparen rparen .)
    plus            reduce using rule 21 (exp -> exp at type dot identifier lparen rparen .)
    minus           reduce using rule 21 (exp -> exp at type dot identifier lparen rparen .)
    times           reduce using rule 21 (exp -> exp at type dot identifier lparen rparen .)
    divide          reduce using rule 21 (exp -> exp at type dot identifier lparen rparen .)
    lt              reduce using rule 21 (exp -> exp at type dot identifier lparen rparen .)
    le              reduce using rule 21 (exp -> exp at type dot identifier lparen rparen .)
    equals          reduce using rule 21 (exp -> exp at type dot identifier lparen rparen .)
    semi            reduce using rule 21 (exp -> exp at type dot identifier lparen rparen .)
    then            reduce using rule 21 (exp -> exp at type dot identifier lparen rparen .)
    rparen          reduce using rule 21 (exp -> exp at type dot identifier lparen rparen .)
    loop            reduce using rule 21 (exp -> exp at type dot identifier lparen rparen .)
    comma           reduce using rule 21 (exp -> exp at type dot identifier lparen rparen .)
    rbrace          reduce using rule 21 (exp -> exp at type dot identifier lparen rparen .)
    else            reduce using rule 21 (exp -> exp at type dot identifier lparen rparen .)
    pool            reduce using rule 21 (exp -> exp at type dot identifier lparen rparen .)
    fi              reduce using rule 21 (exp -> exp at type dot identifier lparen rparen .)
    in              reduce using rule 21 (exp -> exp at type dot identifier lparen rparen .)


state 140

    (39) case_element -> identifier colon type rarrow exp .
    (18) exp -> exp . dot identifier lparen param_list rparen
    (19) exp -> exp . dot identifier lparen rparen
    (20) exp -> exp . at type dot identifier lparen param_list rparen
    (21) exp -> exp . at type dot identifier lparen rparen
    (42) exp -> exp . plus exp
    (43) exp -> exp . minus exp
    (44) exp -> exp . times exp
    (45) exp -> exp . divide exp
    (47) exp -> exp . lt exp
    (48) exp -> exp . le exp
    (49) exp -> exp . equals exp

    semi            reduce using rule 39 (case_element -> identifier colon type rarrow exp .)
    dot             shift and go to state 74
    at              shift and go to state 71
    plus            shift and go to state 72
    minus           shift and go to state 73
    times           shift and go to state 69
    divide          shift and go to state 75
    lt              shift and go to state 70
    le              shift and go to state 67
    equals          shift and go to state 68


state 141

    (20) exp -> exp at type dot identifier lparen param_list rparen .

    of              reduce using rule 20 (exp -> exp at type dot identifier lparen param_list rparen .)
    dot             reduce using rule 20 (exp -> exp at type dot identifier lparen param_list rparen .)
    at              reduce using rule 20 (exp -> exp at type dot identifier lparen param_list rparen .)
    plus            reduce using rule 20 (exp -> exp at type dot identifier lparen param_list rparen .)
    minus           reduce using rule 20 (exp -> exp at type dot identifier lparen param_list rparen .)
    times           reduce using rule 20 (exp -> exp at type dot identifier lparen param_list rparen .)
    divide          reduce using rule 20 (exp -> exp at type dot identifier lparen param_list rparen .)
    lt              reduce using rule 20 (exp -> exp at type dot identifier lparen param_list rparen .)
    le              reduce using rule 20 (exp -> exp at type dot identifier lparen param_list rparen .)
    equals          reduce using rule 20 (exp -> exp at type dot identifier lparen param_list rparen .)
    semi            reduce using rule 20 (exp -> exp at type dot identifier lparen param_list rparen .)
    then            reduce using rule 20 (exp -> exp at type dot identifier lparen param_list rparen .)
    rparen          reduce using rule 20 (exp -> exp at type dot identifier lparen param_list rparen .)
    loop            reduce using rule 20 (exp -> exp at type dot identifier lparen param_list rparen .)
    comma           reduce using rule 20 (exp -> exp at type dot identifier lparen param_list rparen .)
    rbrace          reduce using rule 20 (exp -> exp at type dot identifier lparen param_list rparen .)
    else            reduce using rule 20 (exp -> exp at type dot identifier lparen param_list rparen .)
    pool            reduce using rule 20 (exp -> exp at type dot identifier lparen param_list rparen .)
    fi              reduce using rule 20 (exp -> exp at type dot identifier lparen param_list rparen .)
    in              reduce using rule 20 (exp -> exp at type dot identifier lparen param_list rparen .)

